
%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Downen's publications %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%

@inproceedings{CoScheme,
  title={CoScheme: Compositional Copatterns in Scheme},
  author={Downen, Paul and Corbelino II, Adriano},
  booktitle={International Symposium on Trends in Functional Programming},
  year={2025},
  publisher={Springer},
	numpages={37},
}

@inproceedings{OPLSS-Foundations1,
author = {Paul Downen},
title = {Review},
booktitle = {Oregon Programming Languages Summer School},
series = {OPLSS},
@month = jun,
year = {2017},
@url = {https://www.cs.uoregon.edu/research/summerschool/summer17/topics.php#review},
}

@inproceedings{OPLSS-Foundations2,
author = {Paul Downen and Jan Hoffman},
title = {Foundations of Programming Languages},
booktitle = {Oregon Programming Languages Summer School},
series = {OPLSS},
@month = jul,
year = {2018},
@url = {https://www.cs.uoregon.edu/research/summerschool/summer18/topics.php#review},
}

@inproceedings{OPLSS-Foundations3,
author = {Paul Downen},
title = {Foundations of Programming Languages},
booktitle = {Oregon Programming Languages Summer School},
series = {OPLSS},
@month = jun,
year = {2024},
@url = {https://www.cs.uoregon.edu/research/summerschool/summer24/topics.php#Downen},
}

@inproceedings{OPLSS-AMCR,
author = {Paul Downen},
title = {Abstract Machines and Classical Realizability},
booktitle = {Oregon Programming Languages Summer School},
series = {OPLSS},
@month = jun,
year = {2022},
@url = {https://www.cs.uoregon.edu/research/summerschool/summer22/topics.php#Downen},
}

@phdthesis{DownenPhD,
  author = {Downen, Paul},
  title  = {Sequent Calculus: A Logic and a Language for Computation and Duality},
  school = {University of Oregon, Eugene, OR},
  year   = 2017,
	@url    = {http://hdl.handle.net/1794/22659},
}

@article{D2024CBUV,
  author    = {Paul Downen},
  title     = {Call-by-Unboxed-Value},
  journal   = {Proceedings of the {ACM} on Programming Languages},
  volume    = {8},
  number    = {{ICFP}},
  numpages  = {35},
  year      = {2024},
  @url       = {https://doi.org/10.1145/3674654},
  doi       = {10.1145/3674654},
}

@misc{DA2024CFSC,
  author   = {Paul Downen and
              Zena M. Ariola},
  title    = {A Contextual Formalization of Structural Coinduction},
  year     = 2024,
  numpages = 58,
  note     = {\emph{Under Review} at the Journal of Functional Programming},
	@url = {https://pauldownen.com/publications/coind-proof.pdf},
}

@inproceedings{CCLittlePieces,
  author       = {Zachary J. Sullivan and
                  Paul Downen and
                  Zena M. Ariola},
  @editor       = {Santiago Escobar and
                  Vasco T. Vasconcelos},
  title        = {Closure Conversion in Little Pieces},
  booktitle    = {International Symposium on Principles and Practice of Declarative
                  Programming, {PPDP} 2023, Lisboa, Portugal, October 22-23, 2023},
  pages        = {10:1--10:13},
  publisher    = {{ACM}},
  year         = {2023},
  @url          = {https://doi.org/10.1145/3610612.3610622},
  doi          = {10.1145/3610612.3610622},
}

@article{IntroElimLeftRight,
  author       = {Klaus Ostermann and
                  David Binder and
                  Ingo Skupin and
                  Tim S{\"{u}}berkr{\"{u}}b and
                  Paul Downen},
  title        = {Introduction and elimination, left and right},
  journal      = {Proceedings of the {ACM} on Programming Languages},
  volume       = {6},
  number       = {{ICFP}},
  pages        = {438--465},
  year         = {2022},
  @url          = {https://doi.org/10.1145/3547637},
  doi          = {10.1145/3547637},
}

@article{DA2021CCRMech,
  author       = {Paul Downen and
                  Zena M. Ariola},
  title        = {Classical (co)recursion: Mechanics},
  journal      = {Journal of Functional Programming},
  volume       = {33},
  pages        = {e4},
  year         = {2023},
  @url          = {https://doi.org/10.1017/S0956796822000168},
  doi          = {10.1017/S0956796822000168},
}

@article{DA2021CCRProg,
  author    = {Paul Downen and
               Zena M. Ariola},
  title     = {Classical (Co)Recursion: Programming},
  journal   = {CoRR},
  volume    = {abs/2103.06913},
  year      = {2021},
  @url       = {https://arxiv.org/abs/2103.06913},
  eprinttype = {arXiv},
  eprint    = {2103.06913},
}

@inproceedings{DA2021DIA,
  author    = {Paul Downen and
               Zena M. Ariola},
  @editor    = {Naoki Kobayashi},
  title     = {Duality in Action (Invited Talk)},
  booktitle = {6th International Conference on Formal Structures for Computation
               and Deduction, {FSCD} 2021, July 17-24, 2021, Buenos Aires, Argentina
               (Virtual Conference)},
  series    = {LIPIcs},
  volume    = {195},
  pages     = {1:1--1:32},
  publisher = {Schloss Dagstuhl - Leibniz-Zentrum f{\"{u}}r Informatik},
  year      = {2021},
  @url       = {https://doi.org/10.4230/LIPIcs.FSCD.2021.1},
  doi       = {10.4230/LIPIcs.FSCD.2021.1},
}

@inproceedings{SDA2021SCNSC,
  author    = {Zachary J. Sullivan and
               Paul Downen and
               Zena M. Ariola},
  @editor    = {Sam Lindley and
               Torben {\AE}. Mogensen},
  title     = {Strictly capturing non-strict closures},
  booktitle = {Proceedings of the 2021 {ACM} {SIGPLAN} Workshop on Partial Evaluation
               and Program Manipulation, PEPM@POPL 2021, Virtual Event, Denmark,
               January 18-19, 2021},
  pages     = {74--89},
  publisher = {{ACM}},
  year      = {2021},
  @url       = {https://doi.org/10.1145/3441296.3441398},
  doi       = {10.1145/3441296.3441398},
}

@inproceedings{DAA2020CUCCR,
  author    = {Paul Downen and
               Zena M. Ariola},
  title     = {A Computational Understanding of Classical (Co)Recursion},
  booktitle = {{PPDP}~'20: 22nd International Symposium on Principles and Practice
               of Declarative Programming, Bologna, Italy, 9-10 September, 2020},
  pages     = {5:1--5:13},
  publisher = {{ACM}},
  year      = {2020},
  @url       = {https://doi.org/10.1145/3414080.3414086},
  doi       = {10.1145/3414080.3414086},
}

@article{DAJE2020KACC,
  author    = {Paul Downen and
               Zena M. Ariola and
               Simon Peyton Jones and
               Richard A. Eisenberg},
  title     = {Kinds are calling conventions},
  journal   = {Proceedings of the {ACM} on Programming Languages},
  volume    = {4},
  number    = {{ICFP}},
  pages     = {104:1--104:29},
  year      = {2020},
  @url       = {https://doi.org/10.1145/3408986},
  doi       = {10.1145/3408986},
}

@article{DAA2020CWCC,
  author    = {Paul Downen and
               Zena M. Ariola},
  title     = {Compiling With Classical Connectives},
  journal   = {Logical Methods in Computer Science},
  volume    = {16},
  number    = {3},
  year      = {2020},
  @url       = {https://lmcs.episciences.org/6740},
}

@article{DJFA2019AMSNCC,
author = {Paul Downen and Philip Johnson-Freyd and Zena M. Ariola},
title = {Abstracting Models of Strong Normalization for Classical Calculi},
journal = {Journal of Logical and Algebraic Methods in Programming},
year = {2019},
}

@article{DAG2019DCIU,
author = {Paul Downen and Zena M. Ariola and Silvia Ghilezan},
title = {The Duality of Classical Intersection and Union Types},
journal = {Fundamenta Informaticae},
year = {2019},
volume = {170},
pages = {1--54},
doi = {10.3233/FI-2016-1800},
@url = {http://dx.doi.org/10.3233/FI-2016-1800},
}

@inproceedings{DSAPJ2019MFCET,
author = {Paul Downen and Zachary Sullivan and Zena M. Ariola and Simon {Peyton Jones}},
title = {Making a Faster Curry with Extensional Types},
booktitle = {Proceedings of the 12th {ACM} {SIGPLAN} International Symposium on Haskell, Haskell@ICFP 2019},
series = {Haskell~'19},
pages = {58--70},
@month = aug,
year = 2019,
location = {Berlin, Germany},
@url = {http://doi.acm.org/10.1145/3331545.3342594},
doi = {10.1145/3331545.3342594},
isbn = {978-1-4503-6813-1},
publisher = {ACM},
address = {New York, NY, USA},
keywords = {arity, extensionality, type systems},
abstract = {Curried functions apparently take one argument at a time, which is slow. So optimizing compilers for higher-order languages invariably have some mechanism for working around currying by passing several arguments at once, as many as the function can handle, which is known as its arity. But such mechanisms are often ad-hoc, and do not work at all in higher-order functions. We show how extensional, call-by-name functions have the correct behavior for directly expressing the arity of curried functions. And these extensional functions can stand side-by-side with functions native to practical programming languages, which do not use call-by-name evaluation. Integrating call-by-name with other evaluation strategies in the same intermediate language expresses the arity of a function in its type and gives a principled and compositional account of multi-argument curried functions. An unexpected, but significant, bonus is that our approach is equally suitable for a call-by-value language and a call-by-need language, and it can be readily integrated into an existing compilation framework.}
}

@inproceedings{DSAPJ2019CIA,
author = {Paul Downen and Zachary Sullivan and Zena M. Ariola and Simon {Peyton Jones}},
title = {Codata in Action},
booktitle = {Programming Languages and Systems - 28th European Symposium on Programming, {ESOP} 2019, Held as Part of the European Joint Conferences on Theory and Practice of Software, {ETAPS} 2019},
series = {ESOP~'19},
pages = {119--146},
@month = apr,
year = 2019,
location = {Prague, Czech Republic},
@url = {https://doi.org/10.1007/978-3-030-17184-1\_5},
doi = {10.1007/978-3-030-17184-1\_5},
isbn = {978-3-030-17184-1},
publisher = {Springer International Publishing},
address = {Cham},
abstract = {Computer scientists are well-versed in dealing with data structures. The same cannot be said about their dual: codata. Even though codata is pervasive in category theory, universal algebra, and logic, the use of codata for programming has been mainly relegated to representing infinite objects and processes. Our goal is to demonstrate the benefits of codata as a general-purpose programming abstraction independent of any specific language: eager or lazy, statically or dynamically typed, and functional or object-oriented. While codata is not featured in many programming languages today, we show how codata can be easily adopted and implemented by offering simple inter-compilation techniques between data and codata. We believe codata is a common ground between the functional and object-oriented paradigms; ultimately, we hope to utilize the Curry-Howard isomorphism to further bridge the gap.}
}

@misc{NMFPP,
  author   = {Paul Downen},
  title    = {Numerical Methods with Functional Programming in Python},
  year     = 2018,
  note     = {Unpublished lecture notes.},
	@url      = {https://pauldownen.com/notes/nmfp.pdf},
}


@article{DA2018CCLSC,
author = {Paul Downen and Zena M. Ariola},
title = {A Tutorial on Computational Classical Logic and the Sequent Calculus},
journal = {Journal of Functional Programming},
volume  = 28,
pages = {e3},
year = 2018,
@url = {https://doi.org/10.1017/S0956796818000023},
doi = {10.1017/S0956796818000023},
publisher = {Cambridge University Press},
abstract = {We present a model of computation that heavily emphasizes the concept of duality and the interaction between opposites–production interacts with consumption. The symmetry of this framework naturally explains more complicated features of programming languages through relatively familiar concepts. For example, binding a value to a variable is dual to manipulating the flow of control in a program. By looking at the computational interpretation of the sequent calculus, we find a language that lets us speak about duality, control flow, and evaluation order in programs as first-class concepts.

We begin by reviewing Gentzen's LK sequent calculus and show how the Curry–Howard isomorphism still applies to give us a different basis for expressing computation. We then illustrate how the fundamental dilemma of computation in the sequent calculus gives rise to a duality between evaluation strategies: strict languages are dual to lazy languages. Finally, we discuss how the concept of focusing, developed in the setting of proof search, is related to the idea of type safety for computation expressed in the sequent calculus. In this regard, we compare and contrast two different methods of focusing that have appeared in the literature, static and dynamic focusing, and illustrate how they are two means to the same end.}
}

@inproceedings{DA2018BP,
author = {Paul Downen and Zena M. Ariola},
title = {Beyond Polarity: Towards a Multi-Discipline Intermediate Language with Sharing},
booktitle = {27th {EACSL} Annual Conference on Computer Science Logic},
series = {CSL~'18},
location = {Birmingham, {UK}},
pages = {21:1--21:23},
@month = sep,
year = 2018,
@url = {https://doi.org/10.4230/LIPIcs.CSL.2018.21},
doi = {10.4230/LIPIcs.CSL.2018.21},
ISBN = {978-3-95977-088-0},
ISSN = {1868-8969},
publisher = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
address = {Dagstuhl, Germany},
keywords = {call-by-need, polarity, call-by-push-value, control},
abstract = {The study of polarity in computation has revealed that an "ideal" programming language combines both call-by-value and call-by-name evaluation; the two calling conventions are each ideal for half the types in a programming language. But this binary choice leaves out call-by-need which is used in practice to implement lazy-by-default languages like Haskell. We show how the notion of polarity can be extended beyond the value/name dichotomy to include call-by-need by only adding a mechanism for sharing and the extra polarity shifts to connect them, which is enough to compile a Haskell-like functional language with user-defined types.}
}

@inproceedings{DJFA2018USN,
author = {Paul Downen and Philip Johnson{-}Freyd and Zena M. Ariola},
title = {Uniform Strong Normalization for Multi-discipline Calculi},
booktitle = {Rewriting Logic and Its Applications},
series = {WRLA~'18},
pages = {205--225},
year = 2018,
@month = jun,
location = {Thessaloniki, Greece},
@url = {https://doi.org/10.1007/978-3-319-99840-4\_12},
doi = {10.1007/978-3-319-99840-4\_12},
isbn = {978-3-319-99840-4},
publisher = {Springer International Publishing},
address = {Cham},
abstract = {Modern programming languages have effects and mix multiple calling conventions, and their core calculi should too. We characterize calling conventions by their ``substitution discipline'' that says what variables stand for, and design calculi for mixing disciplines in a single program. Building on variations of the reducibility candidates method, including biorthogonality and symmetric candidates which are both specialized for one discipline, we develop a single uniform framework for strong normalization encompassing call-by-name, call-by-value, call-by-need, call-by-push-value, non-deterministic disciplines, and any others satisfying some simple criteria. We explicate commonalities of previous methods and show they are special cases of the uniform framework and they extend to multi-discipline programs.}
}

@inproceedings{MDAPJ2017CWC,
author = {Maurer, Luke and Downen, Paul and Ariola, Zena M. and Peyton Jones, Simon},
title = {Compiling Without Continuations},
booktitle = {Proceedings of the 38th {ACM} {SIGPLAN} Conference on Programming Language Design and Implementation},
series = {PLDI~'17},
@month = jun,
year = 2017,
location = {Barcelona, Spain},
pages = {482--494},
doi = {10.1145/3062341.3062380},
@url = {http://dx.doi.org/10.1145/3062341.3062380},
publisher = {ACM},
address = {New York, NY, USA},
keywords = {Intermediate languages; CPS; ANF; Stream fusion; Haskell; GHC},
abstract = {Many fields of study in compilers give rise to the concept of a join point—a place where different execution paths come together. Join points are often treated as functions or continuations, but we believe it is time to study them in their own right. We show that adding join points to a direct-style functional intermediate language is a simple but powerful change that allows new optimizations to be performed, including a significant improvement to list fusion. Finally, we report on recent work on adding join points to the intermediate language of the Glasgow Haskell Compiler.}
}

@article{JFDA2017CBNEC,
author = {Johnson-Freyd, Philip and Downen, Paul and Ariola, Zena M.},
title = {Call-by-name Extensionality and Confluence},
journal = {Journal of Functional Programming},
year = 2017,
volume = 27,
pages = {e12},
doi = {10.1017/S095679681700003X},
@url = {http://dx.doi.org/10.1017/S095679681700003X},
publisher = {Cambridge University Press},
abstract = {Designing rewriting systems that respect functional extensionality for call-by-name languages with effects turns out to be surprisingly challenging. Simply interpreting extensional laws like η as reduction rules easily breaks confluence. We explore these issues in the setting of a sequent calculus. Building on an insight that appears in different aspects of the theory of call-by-name functional languages—confluent rewriting for two independent control calculi and sound continuation-passing style transformations—we give a confluent reduction system for lazy extensional functions. Finally, we consider limitations to this approach when used for strict evaluation and types beyond functions.}
}

@inproceedings{DMAPJ2016SCCIL,
author = {Downen, Paul and Maurer, Luke and Ariola, Zena M. and Peyton Jones, Simon},
title = {Sequent Calculus As a Compiler Intermediate Language},
booktitle = {Proceedings of the 21st {ACM} {SIGPLAN} International Conference on Functional Programming},
series = {ICFP~'16},
year = 2016,
isbn = {978-1-4503-4219-3},
location = {Nara, Japan},
pages = {74--88},
numpages = 15,
@url = {http://doi.acm.org/10.1145/2951913.2951931},
doi = {10.1145/2951913.2951931},
acmid = 2951931,
publisher = {ACM},
address = {New York, NY, USA},
keywords = {Compiler optimizations, Continuations, Haskell, Intermediate representations, Natural deduction, Sequent calculus},
abstract = {The λ-calculus is popular as an intermediate language for practical compilers. But in the world of logic it has a lesser-known twin, born at the same time, called the sequent calculus. Perhaps that would make for a good intermediate language, too? To explore this question we designed Sequent Core, a practically-oriented core calculus based on the sequent calculus, and used it to re-implement a substantial chunk of the Glasgow Haskell Compiler.}
}

@inproceedings{MDAPJ2016ANFC,
author = {Maurer, Luke and Downen, Paul and Ariola, Zena M. and Peyton Jones, Simon},
title = {Administrative normal form, continued: Sharing control in direct style},
booktitle = {The 5th ACM SIGPLAN Workshop on Higher-Order Programming with Effects},
series = {HOPE~'16},
@month = sep,
year = 2016,
abstract = {Administrative normal form (ANF) promises to reap the benefits of continuation-passing style (CPS) while retaining the advantages of direct style. However, we believe ANF falls short of this ideal because it does not provide a satisfactory way to describe shared control flow, as CPS does naturally. We show how CPS itself can guide us in adding a control effect to ANF and taming it to regain purity, guaranteeing an efficient implementation. Interestingly, even though CPS is usually used for compiling call-by-value languages, our technique is independent of the evaluation strategy. In short, we propose that the known advantages of CPS can be achieved by extending ANF, or in general a direct-style representation. Does this mean that CPS is finally out? No: whatever the compiler’s chosen representation, we suspect CPS will reveal new insights about program manipulation.}
}

@inproceedings{JFDA2015FCCS,
author = {Johnson-Freyd, Philip and Downen, Paul and Ariola, Zena M.},
title = {First Class Call Stacks: Exploring Head Reduction},
booktitle = {Proceedings of the Workshop on Continuations, {WoC} 2016, {London, UK}, {April} 12th 2015},
series = {{EPTCS}},
volume = 212,
year = 2016,
doi = {10.4204/EPTCS.212},
@url = {http://dx.doi.org/10.4204/EPTCS.212},
abstract = {Weak-head normalization is inconsistent with functional extensionality in the call-by-name λ-calculus. We explore this problem from a new angle via the conflict between extensionality and effects. Leveraging ideas from work on the λ-calculus with control, we derive and justify alternative operational semantics and a sequence of abstract machines for performing head reduction. Head reduction avoids the problems with weak-head reduction and extensionality, while our operational semantics and associated abstract machines show us how to retain weak-head reduction's ease of implementation.Weak-head normalization is inconsistent with functional extensionality in the call-by-name λ-calculus. We explore this problem from a new angle via the conflict between extensionality and effects. Leveraging ideas from work on the λ-calculus with control, we derive and justify alternative operational semantics and a sequence of abstract machines for performing head reduction. Head reduction avoids the problems with weak-head reduction and extensionality, while our operational semantics and associated abstract machines show us how to retain weak-head reduction's ease of implementation.}
}

@inproceedings{DJFA2015SSR,
author = {Downen, Paul and Johnson-Freyd, Philip and Ariola, Zena M.},
title = {Structures for Structural Recursion},
booktitle = {Proceedings of the 20th {ACM} {SIGPLAN} International Conference on Functional Programming},
series = {ICFP~'15},
year = 2015,
isbn = {978-1-4503-3669-7},
location = {Vancouver, BC, Canada},
pages = {127--139},
numpages = 13,
@url = {http://doi.acm.org/10.1145/2784731.2784762},
doi = {10.1145/2784731.2784762},
acmid = 2784762,
publisher = {ACM},
address = {New York, NY, USA},
keywords = {Classical Logic, Coinduction, Duality, Induction, Recursion, Sequent Calculus, Strong Normalization, Structures},
abstract = {Our goal is to develop co-induction from our understanding of induction, putting them on level ground as equal partners for reasoning about programs. We investigate several structures which represent well-founded forms of recursion in programs. These simple structures encapsulate reasoning by primitive and noetherian induction principles, and can be composed together to form complex recursion schemes for programs operating over a wide class of data and co-data types. At its heart, this study is guided by duality: each structure for recursion has a dual form, giving perfectly symmetric pairs of equal and opposite data and co-data types for representing recursion in programs. Duality is brought out through a framework presented in sequent style, which inherently includes control effects that are interpreted logically as classical reasoning principles. To accommodate the presence of effects, we give a calculus parameterized by a notion of strategy, which is strongly normalizing for a wide range of strategies. We also present a more traditional calculus for representing effect-free functional programs, but at the cost of losing some of the founding dualities.}
}

@inproceedings{JDA2015CCEE,
author = {Johnson-Freyd, Philip and Downen, Paul and Ariola, Zena M.},
title = {Control Controls Extensional Execution},
booktitle = {The 4th ACM SIGPLAN Workshop on Higher-Order Programming with Effects},
series = {HOPE~'15},
@month = aug,
year = 2015,
abstract = {Call-by-name evaluation, weak head normal forms, and functional
extensionality: pick at most two.  All three seem desirable, but are
inconsistent together, representing a trilemma.  We can respect
extensionality while computing to weak head normal forms---where
evaluation stops once it hits a lambda---by switching to call-by-value
evaluation, but sticking with call-by-name forces us to abandon one of
the other two.  Weak head normal forms are appealing since they let us
run closed programs without going under binders, which seems well
suited for implementations.  The essential problem, though, is that
``stopping at a lambda'' is fundamentally inconsistent with the $\eta$
axiom which can erase top-level lambdas.

When we move from the pure, untyped $\lambda$-calculus to one with
first-class control effects, the situation becomes even worse.  Not
only are we faced with our original trilemma, but $\eta$ reduction
breaks confluence as well.  Recent work restores
confluence in control calculi by replacing $\eta$ with a different
interpretation of extensionality and $\beta$ with a different
interpretation of functions.  We bring new insight into these
solutions by recasting functions as \emph{pattern matching}
abstractions on their calling contexts.  Further, by translating this
alternate viewpoint back to the $\lambda$-calculus, we derive an
abstract machine for call-by-name evaluation which respects $\eta$,
keeps evaluation at the top level, and avoids any descent under binders.
Our machine sidesteps the trilemma by going further and computing to
head normal forms.  Effectively, control has taught us a better way to
implement the pure $\lambda$-calculus.}
}

@inproceedings{DownenAriola2014CSCC,
author = {Downen, Paul and Ariola, Zena M.},
title = {Compositional Semantics for Composable Continuations: From Abortive to Delimited Control},
booktitle = {Proceedings of the 19th {ACM} {SIGPLAN} International Conference on Functional Programming},
series = {ICFP~'14},
year = 2014,
isbn = {978-1-4503-2873-9},
location = {Gothenburg, Sweden},
pages = {109--122},
numpages = 14,
@url = {http://doi.acm.org/10.1145/2628136.2628147},
doi = {10.1145/2628136.2628147},
acmid = 2628147,
publisher = {ACM},
address = {New York, NY, USA},
keywords = {continuation-passing style, delimited control, equational theory, evaluation strategy, program transformation},
abstract = {Parigot's λμ-calculus, a system for computational reasoning about classical proofs, serves as a foundation for control operations embodied by operators like Scheme's callcc. We demonstrate that the call-by-value theory of the λμ-calculus contains a latent theory of delimited control, and that a known variant of λμ which unshackles the syntax yields a calculus of composable continuations from the existing constructs and rules for classical control. To relate to the various formulations of control effects, and to continuation-passing style, we use a form of compositional program transformations which preserves the underlying structure of equational theories, contexts, and substitution. Finally, we generalize the call-by-name and call-by-value theories of the λμ-calculus by giving a single parametric theory that encompasses both, allowing us to generate a call-by-need instance that defines a calculus of classical and delimited control with lazy evaluation and sharing.}
}

@inproceedings{DMAV2014CPS,
author = {Downen, Paul and Maurer, Luke and Ariola, Zena M. and Varacca, Daniele},
title = {Continuations, Processes, and Sharing},
booktitle = {Proceedings of the 16th International Symposium on Principles and Practice of Declarative Programming},
series = {PPDP~'14},
year = 2014,
isbn = {978-1-4503-2947-7},
location = {Canterbury, United Kingdom},
pages = {69--80},
numpages = 12,
@url = {http://doi.acm.org/10.1145/2643135.2643155},
doi = {10.1145/2643135.2643155},
acmid = 2643155,
publisher = {ACM},
address = {New York, NY, USA},
keywords = {π-calculus, bisimulation, call-by-need, continuation-passing style, effects, processes, transforms},
abstract = {Continuation-passing style (CPS) transforms have long been important tools in the study of programming. They have been shown to correspond to abstract machines and, when combined with a naming transform that expresses shared values, they enjoy a direct correspondence with encodings into process calculi such as the π-calculus. We present our notion of correctness and discuss the sufficient conditions that guarantee the correctness of transforms. We then consider the call-by-value, call-by-name and call-by-need evaluation strategies for the λ-calculus and present their CPS transforms, abstract machines, π-encodings, and proofs of correctness. Our analysis covers a uniform CPS transform, which differentiates the three evaluation strategies only by the treatment of function calls. This leads to a new CPS transform for call-by-need requiring a less expressive form of side effect, which we call constructive update.}
}

@inproceedings{DA2014DCMPTP,
author = {Downen, Paul and Ariola, Zena M.},
title = {Delimited control with multiple prompts in theory and practice},
booktitle = {The 3rd ACM SIGPLAN Workshop on Higher-Order Programming with Effects},
series = {HOPE~'14},
@month = aug,
year = 2014,
abstract = {The versatile and expressive capabilities of delimited control and composable continuations have gained it attention in both the theory and practice of functional programming with effects.  On the more theoretical side, delimited control may be used as a basis for explaining and understanding a wide variety of other computational effects, like mutable state and exceptions, based on Filinski's (1994, 1999) observation that composable continuations can be used to represent any monadic effect.  On the more practical side, forms of delimited control have been implemented in real-world programming languages (Flatt et al., 2007; Dybvig et al. 2007; Kiselyov, 2010), and used in the design of libraries like for creating web servers (Flatt, 2007).

However, the design space for adding composable continuations to a programming language is vast, and a number of different definitions of delimited control operators have been proposed (Felleisen, 1988; Danvy and Filinski, 1989; Sitram and Felleisen, 1990; Danvy and Filinski, 1990; Gunter et al., 1995 ).  This has, in part, caused the theory and practice of delimited control to diverge somewhat from one another: the operators we most often study in theory are typically not the ones we use in practice.  In this 30 minute talk, we will consider some of the fundamental, though subtle, differences in delimited control operators that appear in the literature and in programming languages, and some of the efforts to connect these together.  We will also look at a common extension of delimited control that occurs in practice --- the ability to delimit multiple different operations by name, much like exception handlers for specific subsets of errors --- and how it provides another, novel approach for bridging the gap between the different frameworks.}
}

@incollection{DownenAriola2014DC,
author = {Downen, Paul and Ariola, Zena M.},
title = {The Duality of Construction},
booktitle = {Programming Languages and Systems: 23rd {E}uropean Symposium on Programming, {ESOP} 2014, Held as Part of the {E}uropean Joint Conferences on Theory and Practice of Software, {ETAPS} 2014},
@series = {ESOP 2014},
@series = {Lecture Notes in Computer Science},
location = {Grenoble, France},
@month = apr,
year = 2014,
pages = {249--269},
volume = 8410,
@editor = {Shao, Zhong},
isbn = {978-3-642-54832-1},
doi = {10.1007/978-3-642-54833-8_14},
@url = {http://dx.doi.org/10.1007/978-3-642-54833-8_14},
publisher = {Springer Berlin Heidelberg},
language = {English},
abstract = {We explore the duality of construction and deconstruction in the presence of different evaluation strategies. We characterize an evaluation strategy by the notion of substitutability, given by defining what is a value and a co-value, and we present an equational theory that takes the strategy as a parameter. The theory may be extended with new logical connectives, in the form of user-defined data and co-data types, which are duals of one another. Finally, we explore a calculus with composite evaluation strategies that allow for more flexibility over evaluation order by mingling multiple primitive strategies within a single program.}
}

@article{DownenAriola2014DCCE,
author = {Downen, Paul and Ariola, Zena M.},
title = {Delimited Control and Computational Effects},
journal = {Journal of Functional Programming},
volume = 24,
issue = 01,
year = 2014,
issn = {1469-7653},
pages = {1--55},
numpages = 55,
doi = {10.1017/S0956796813000312},
@URL = {http://journals.cambridge.org/article_S0956796813000312},
publisher = {Cambridge University Press},
abstract = {We give a framework for delimited control with multiple prompts, in the style of Parigot's λμ-calculus, through a series of incremental extensions by starting with the pure λ-calculus. Each language inherits the semantics and reduction theory of its parent, giving a systematic way to describe each level of control. For each language of interest, we fully characterize its semantics in terms of a reduction semantics, operational semantics, continuation-passing style transform, and abstract machine. Furthermore, the control operations are expressed in terms of fine-grained primitives that can be used to build well-known, higher-level control operators. In order to illustrate the expressive power provided by various languages, we show how other computational effects can be encoded in terms of these control operators.}
}

@incollection{ADHNS2012CCSC,
author = {Ariola, Zena M. and Downen, Paul and Herbelin, Hugo and Nakata, Keiko and Saurin, Alexis},
title = {Classical Call-by-Need Sequent Calculi: The Unity of Semantic Artifacts},
booktitle = {Functional and Logic Programming: 11th International Symposium},
@series = {FLOPS 2012},
@series = {Lecture Notes in Computer Science},
location = {Kobe, Japan},
@month = may,
year = 2012,
pages = {32--46},
volume = 7294,
@editor = {Schrijvers, Tom and Thiemann, Peter},
isbn = {978-3-642-29821-9},
doi = {10.1007/978-3-642-29822-6_6},
@url = {http://dx.doi.org/10.1007/978-3-642-29822-6_6},
publisher = {Springer Berlin Heidelberg},
address={Berlin, Heidelberg},
language = {English},
keywords = {call-by-need; lazy evaluation; duality of computation; sequent calculus; λμ-calculus; classical logic; control},
abstract = {We systematically derive a classical call-by-need sequent calculus, which does not require an unbounded search for the standard redex, by using the unity of semantic artifacts proposed by Danvy \emph{et al.} The calculus serves as an intermediate step toward the generation of an environment-based abstract machine. The resulting abstract machine is context-free, so that each step is parametric in all but one component. The context-free machine elegantly leads to an environment-based CPS transformation. This transformation is observationally different from a natural classical extension of the transformation of Okasaki \emph{et al.}, due to duplication of un-evaluated bindings.}
}

@incollection{DownenAriola2012SADCMP,
author = {Downen, Paul and Ariola, Zena M.},
title = {A Systematic Approach to Delimited Control with Multiple Prompts},
booktitle = {Programming Languages and Systems: 21st {E}uropean Symposium on Programming, {ESOP} 2012, Held as Part of the {E}uropean Joint Conferences on Theory and Practice of Software, {ETAPS} 2012},
@series = {ESOP 2012},
@series = {Lecture Notes in Computer Science},
location = {Tallinn, Estonia},
@month = mar,
year = 2012,
pages = {234--253},
volume = 7211,
isbn = {978-3-642-28868-5},
doi = {10.1007/978-3-642-28869-2_12},
@url = {http://dx.doi.org/10.1007/978-3-642-28869-2_12},
@editor = {Seidl, Helmut},
publisher = {Springer Berlin Heidelberg},
language = {English},
@note = {Best Paper Award Nominee},
keywords = {Delimited control; dynamic variables; shift; reset; multiple prompts},
abstract = {We formalize delimited control with multiple prompts, in the style of Parigot’s λμ-calculus, through a series of incremental extensions by starting with the pure λ-calculus. Each language inherits the semantics and reduction theory of its parent, giving a systematic way to describe each level of control.}
}


@book{Curry58,
  author      = {Haskell B. Curry and Robert Feys and William Craig},
  title       = {Combinatory Logic},
  volume      = 1,
  publisher   = "North-Holland",
  year        = 1958,
}

@techreport{deBruijn1968ALM,
author = {de Bruijn, Nicolaas},
title = {{AUTOMATH}, a Language for Mathematics},
number = {66-WSK-05},
institution = {Technological University Eindhoven},
@month = nov,
year = 1968,
}

@incollection{Howard1980FTNC,
author = {William A. Howard},
title = {The Formulae-as-Types Notion of Constructions},
booktitle = {To {H.B. Curry}: Essays on Combinatory Logic, Lambda Calculus and Formalism},
@editors = {J. P. Seldin and J. R. Hindley},
publisher = {Academic Press},
year = 1980,
pages = {479--490},
numpages = 12,
isbn = {0123490502},
note = {Unpublished manuscript of 1969},
}

@book{LambekScott1986IHOCL,
title = {Introduction to Higher Order Categorical Logic},
author = {Lambek, Joachim and Scott, Philip J.},
year = 1986,
isbn = {0-521-24665-2},
publisher = {Cambridge University Press},
address = {New York, NY, USA},
}

@article{HoareLogic,
author = {Hoare, C. A. R.},
title = {An Axiomatic Basis for Computer Programming},
year = {1969},
issue_date = {Oct. 1969},
publisher = {ACM},
address = {New York, NY, USA},
volume = {12},
number = {10},
issn = {0001-0782},
@url = {https://doi.org/10.1145/363235.363259},
doi = {10.1145/363235.363259},
abstract = {In this paper an attempt is made to explore the logical foundations of computer programming by use of techniques which were first applied in the study of geometry and have later been extended to other branches of mathematics. This involves the elucidation of sets of axioms and rules of inference which can be used in proofs of the properties of computer programs. Examples are given of such axioms and rules, and a formal proof of a simple theorem is displayed. Finally, it is argued that important advantage, both theoretical and practical, may follow from a pursuance of these topics.},
journal = {Communications of the ACM},
@month = {oct},
pages = {576–580},
numpages = {5},
keywords = {program documentation, formal language definition, theory of programming' proofs of programs, axiomatic method, machine-independent programming, programming language design}
}

@incollection{AssigningMeaningToPrograms,
  title={Assigning meanings to programs},
  author={Floyd, Robert W},
  booktitle={Program Verification},
  pages={65--81},
  year={1993},
  publisher={Springer}
}

@inproceedings{GriffinControl,
author = {Griffin, Timothy G.},
title = {A formulae-as-type notion of control},
year = {1989},
isbn = {0897913434},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/96709.96714},
doi = {10.1145/96709.96714},
abstract = {The programming language Scheme contains the control construct call/cc that allows access to the current continuation (the current control context). This, in effect, provides Scheme with first-class labels and jumps. We show that the well-known formulae-as-types correspondence, which relates a constructive proof of a formula α to a program of type α, can be extended to a typed Idealized Scheme. What is surprising about this correspondence is that it relates classical proofs to typed programs. The existence of computationally interesting “classical programs” —programs of type α, where α holds classically, but not constructively — is illustrated by the definition of conjunctively, disjunctive, and existential types using standard classical definitions. We also prove that all evaluations of typed terms in Idealized Scheme are finite.},
booktitle = {Proceedings of the 17th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {47–58},
numpages = {12},
location = {San Francisco, California, USA},
series = {POPL~'90}
}

@inproceedings{breitner14,
  author    = {Joachim Breitner},
  title     = {Call Arity},
  booktitle = {Trends in Functional Programming - 15th International Symposium, {TFP}
               2014, Soesterberg, The Netherlands, May 26-28, 2014. Revised Selected
               Papers},
  pages     = {34--50},
  year      = {2014},
}

@inproceedings{bolingbroke09,
  author = {Bolingbroke, Maximilian C. and Peyton Jones, Simon L.},
  title = {Types Are Calling Conventions},
  booktitle = {Proceedings of the 2nd ACM SIGPLAN Symposium on Haskell},
  series = {Haskell~'09},
  year = {2009},
  location = {Edinburgh, Scotland},
  pages = {1--12},
  numpages = {12},
}

@phdthesis{levy01,
  author = {Levy, Paul Blain},
  title  = {Call-By-Push-Value},
  school = {Queen Mary and Westfield College, University of London},
  year   = {2001},
}

@inproceedings{marlow04,
  author    = {Simon Marlow and
               Simon L. {Peyton Jones}},
  title     = {Making a fast curry: push/enter vs. eval/apply for higher-order languages},
  booktitle = {Proceedings of the Ninth {ACM} {SIGPLAN} International Conference
               on Functional Programming, {ICFP} 2004, Snow Bird, UT, USA, September
               19-21, 2004},
  pages     = {4--15},
  year      = {2004},
}

@inproceedings{LevityPoly,
  author    = {Richard A. Eisenberg and
               Simon {Peyton Jones}},
  title     = {Levity polymorphism},
  booktitle = {Proceedings of the 38th {ACM} {SIGPLAN} Conference on Programming
               Language Design and Implementation, {PLDI} 2017, Barcelona, Spain,
               June 18-23, 2017},
  pages     = {525--539},
  year      = {2017},
}

@inproceedings{PeytonJones:1991:unboxed,
 author = {Peyton Jones, Simon L. and Launchbury, John},
 title = {Unboxed Values As First Class Citizens in a Non-Strict Functional Language},
 booktitle = {Proceedings of the 5th ACM Conference on Functional Programming Languages and Computer Architecture},
 year = {1991},
 isbn = {3-540-54396-1},
 pages = {636--666},
 numpages = {31},
 acmid = {652528},
 publisher = {Springer-Verlag},
 address = {London, UK, UK},
}

@article{Plotkin1975CBNCBVLC,
author = {Gordon D. Plotkin},
title = {Call-By-Name, Call-By-Value and the {$\lambda$}-Calculus},
journal = {Theoretical Computer Science},
volume = 1,
issue = 2,
pages = {125--159},
year = 1975,
issn = {0304-3975},
@url = {http://dx.doi.org/10.1016/0304-3975(75)90017-1},
doi = {10.1016/0304-3975(75)90017-1},
publisher = {North-Holland Publishing Company},
}

@inproceedings{AMOFW1995CBNLC,
author = {Ariola, Zena M. and Maraist, John and Odersky, Martin and Felleisen, Matthias and Wadler, Philip},
title = {A Call-By-Need Lambda Calculus},
booktitle = {Proceedings of the 22nd {ACM} {SIGPLAN-SIGACT} Symposium on Principles of Programming Languages},
series = {POPL~'95},
year = 1995,
isbn = {0-89791-692-1},
location = {San Francisco, California, USA},
pages = {233--246},
numpages = 14,
doi = {10.1145/199448.199507},
acmid = 199507,
publisher = {ACM},
address = {New York, NY, USA},
}

@inproceedings{dunfield15,
  author    = {Joshua Dunfield},
  title     = {Elaborating evaluation-order polymorphism},
  booktitle = {Proceedings of the 20th {ACM} {SIGPLAN} International Conference on
               Functional Programming, {ICFP} 2015, Vancouver, BC, Canada, September
               1-3, 2015},
  pages     = {256--268},
  year      = {2015},
}

@article{dargaye09,
  author    = {Zaynah Dargaye and
               Xavier Leroy},
  title     = {A verified framework for higher-order uncurrying optimizations},
  journal   = {Higher-Order and Symbolic Computation},
  volume    = {22},
  number    = {3},
  pages     = {199--231},
  year      = {2009},
	@url = {https://doi.org/10.1007/s10990-010-9050-z},
}

@inproceedings{Leroy07FVOC,
  author       = {Xavier Leroy},
  @editor       = {Franz Baader},
  title        = {Formal Verification of an Optimizing Compiler},
  booktitle    = {Term Rewriting and Applications, 18th International Conference, {RTA}
                  2007, Paris, France, June 26-28, 2007, Proceedings},
  @series       = {Lecture Notes in Computer Science},
  volume       = {4533},
  pages        = {1},
  publisher    = {Springer},
  year         = {2007},
  @url          = {https://doi.org/10.1007/978-3-540-73449-9\_1},
  doi          = {10.1007/978-3-540-73449-9\_1},
}

@inproceedings{KLBSSF2017,
  TITLE = {{Closing the Gap -- The Formally Verified Optimizing Compiler CompCert}},
  AUTHOR = {K{\"a}stner, Daniel and Leroy, Xavier and Blazy, Sandrine and Schommer, Bernhard and Schmidt, Michael and Ferdinand, Christian},
  @URL = {https://inria.hal.science/hal-01399482},
  BOOKTITLE = {{SSS'17: Safety-critical Systems Symposium 2017}},
  ADDRESS = {Bristol, United Kingdom},
  PUBLISHER = {{CreateSpace}},
  SERIES = {Developments in System Safety Engineering: Proceedings of the Twenty-fifth Safety-critical Systems Symposium},
  PAGES = {163-180},
  YEAR = {2017},
  @MONTH = Feb,
  PDF = {https://inria.hal.science/hal-01399482/file/SSS2017_kaestner_et_al.pdf},
  HAL_ID = {hal-01399482},
  HAL_VERSION = {v1},
}

@inproceedings{hannanICFP98,
  author    = {John Hannan and
               Patrick Hicks},
  title     = {Higher-Order Arity Raising},
  booktitle = {Proceedings of the third {ACM} {SIGPLAN} International Conference
               on Functional Programming {(ICFP}~'98), Baltimore, Maryland, USA,
               September 27-29, 1998.},
  pages     = {27--38},
  year      = {1998},
}

@inproceedings{bergstrom:arity-raising,
 author = {Bergstrom, Lars and Reppy, John},
 title = {Arity Raising in Manticore},
 booktitle = {Proceedings of the 21st International Conference on Implementation and Application of Functional Languages},
 series = {IFL~'09},
 year = {2010},
 isbn = {3-642-16477-3, 978-3-642-16477-4},
 location = {South Orange, NJ, USA},
 pages = {90--106},
 numpages = {17},
 @url = {http://dl.acm.org/citation.cfm?id=1929087.1929093},
 acmid = {1929093},
 publisher = {Springer-Verlag},
 address = {Berlin, Heidelberg},
}


@techreport{leroy90,
  author = {Xavier Leroy},
  title = {The {ZINC} experiment: an economical
                         implementation of the {ML} language},
  institution = {INRIA},
  type = {Technical report},
  number = {117},
  year = {1990},
}

@inproceedings{cousineau85,
  author    = {Guy Cousineau and
               Pierre{-}Louis Curien and
               Michel Mauny},
  title     = {The Categorical Abstract Machine},
  booktitle = {Functional Programming Languages and Computer Architecture, {FPCA}
               1985, Nancy, France, September 16-19, 1985, Proceedings},
  pages     = {50--64},
  year      = {1985},
}

@article{hutton:worker-wrapper,
 author = {Gill, Andy and Hutton, Graham},
 title = {The Worker/Wrapper Transformation},
 journal = {Journal of Functional Programming},
 issue_date = {March 2009},
 volume = {19},
 number = {2},
 @month = mar,
 year = {2009},
 pages = {227--251},
 doi = {10.1017/S0956796809007175},
}

@unpublished{xu05,
  author = {Xu, Dana N. and Peyton Jones, Simon L.},
  title = {Arity Analysis},
  year = {2005},
  note = {Working notes},
}

@inproceedings{sergey14,
 author = {Sergey, Ilya and Vytiniotis, Dimitrios and Peyton Jones, Simon},
 title = {Modular, Higher-order Cardinality Analysis in Theory and Practice},
 booktitle = {Proceedings of the 41st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
 series = {POPL~'14},
 year = {2014},
 location = {San Diego, California, USA},
 pages = {335--347},
 numpages = {13},
}

@incollection{krivine2009realizability,
   author={Krivine, Jean-Louis},
   title={Realizability in classical logic},
   booktitle={Interactive models of computation and program behaviour},
   journal={Panoramas et synth{\`e}ses},
   publisher={Soci{\'e}t{\'e} Math{\'e}matique de France},
   volume={27},
   @pages={197--229},
   year={2005}
}

@Article{Krivine2007CBNLCM,
author = {Krivine, Jean-Louis},
title = {A Call-By-Name Lambda-Calculus Machine},
journal = {Higher-Order and Symbolic Computation},
year = 2007,
volume = 20,
number = 3,
pages = {199--207},
@issn = {1573-0557},
doi = {10.1007/s10990-007-9018-9},
abstract = {We present a particularly simple lazy lambda-calculus machine, which was introduced twenty-five years ago. It has been, since, used and implemented by several authors, but remained unpublished. We also build an extension, with a control instruction and continuations. This machine was conceived in order to execute programs obtained from mathematical proofs, by means of the Curry-Howard (also known as ``proof-program'') correspondence. The control instruction corresponds to the axiom of excluded middle.},
}

@article{Pitts2000PPOE,
 author = {Pitts, Andrew M.},
 title = {Parametric Polymorphism and Operational Equivalence},
 journal = {Mathematical Structures in Computer Science},
 volume = {10},
 number = {3},
 @month = jun,
 year = {2000},
 issn = {0960-1295},
 pages = {321--359},
 numpages = {39},
 @url = {http://dx.doi.org/10.1017/S0960129500003066},
 doi = {10.1017/S0960129500003066},
 acmid = {967002},
 publisher = {Cambridge University Press},
 address = {New York, NY, USA},
}

@inproceedings{Barbanera1994SLC,
  author    = {Franco Barbanera and
               Stefano Berardi},
  title     = {A Symmetric Lambda Calculus for ``Classical'' Program Extraction},
  booktitle = {Theoretical Aspects of Computer Software, International Conference
               {TACS}~'94, Sendai, Japan, April 19-22, 1994, Proceedings},
  pages     = {495--515},
  year      = {1994},
  @url       = {https://doi.org/10.1007/3-540-57887-0\_112},
  doi       = {10.1007/3-540-57887-0\_112},
}

@inproceedings{hannanPOPL98,
  author    = {John Hannan and
               Patrick Hicks},
  title     = {Higher-Order unCurrying},
  booktitle = {{POPL}~'98, Proceedings of the 25th {ACM} {SIGPLAN-SIGACT} Symposium
               on Principles of Programming Languages, San Diego, CA, USA, January
               19-21, 1998},
  pages     = {1--11},
  year      = {1998},
}

@inproceedings{Wadler2003CBVDCBN,
author = {Wadler, Philip},
title = {Call-By-Value is Dual to Call-By-Name},
booktitle = {Proceedings of the Eighth {ACM} {SIGPLAN} International Conference on Functional Programming},
year = 2003,
@isbn = {1-58113-756-7},
location = {Uppsala, Sweden},
pages = {189--201},
numpages = 13,
@url = {http://doi.acm.org/10.1145/944705.944723},
doi = {10.1145/944705.944723},
acmid = 944723,
publisher = {ACM},
address = {New York, NY, USA},
keywords = {Curry-Howard correspondence, De Morgan dual, lambda calculus, lambda mu calculus, logic, natural deduction, sequent calculus},
}

@inproceedings{CurienHerbelin2000DC,
author = {Curien, Pierre-Louis and Herbelin, Hugo},
title = {The Duality of Computation},
booktitle = {Proceedings of the Fifth {ACM} {SIGPLAN} International Conference on Functional Programming},
series = {ICFP~'00},
year = 2000,
@isbn = {1-58113-202-6},
pages = {233--243},
numpages = 11,
@url = {http://doi.acm.org/10.1145/351240.351262},
doi = {10.1145/351240.351262},
@acmid = 351262,
publisher = {ACM},
address = {New York, NY, USA},
}

@mastersthesis{Filinski1989masters,
author = {Andrzej Filinski},
title = {Declarative Continuations and Categorical Duality},
school = {Computer Science Department, University of Copenhagen},
year = 1989,
}

@article{SabryFelleisen1993RAPCPS,
author = {Sabry, Amr and Felleisen, Matthias},
title = {Reasoning About Programs in Continuation-Passing Style},
journal = {Lisp and Symbolic Computation},
issue_date = {Nov. 1993},
volume = 6,
number = {3-4},
@month = nov,
year = 1993,
issn = {0892-4635},
pages = {289--360},
numpages = 72,
@url = {http://dx.doi.org/10.1007/BF01019462},
doi = {10.1007/BF01019462},
acmid = 198120,
publisher = {Kluwer Academic Publishers},
address = {Hingham, MA, USA},
keywords = {{\$\lambda\$}-calculus, {\$\lambda\$}v-C-calculus, {\$\lambda\$}v-calculus, CPS transformations, IOCC, continuation-passing style, inverse CPS transformations},
}

@inproceedings{Reynolds1974TTTS,
author = {Reynolds, John C.},
title = {Towards a Theory of Type Structure},
booktitle = {Programming Symposium, Proceedings Colloque Sur La Programmation},
@editor = {Bernard Robinet},
@series = {Lecture Notes in Computer Science},
volume = 19,
year = 1974,
location = {Paris, France},
isbn = {3-540-06859-7},
pages = {408--423},
numpages = 16,
publisher = {Springer-Verlag},
address = {London, UK, UK},
}

@book{GTL1989PT,
author = {Girard, Jean-Yves and Taylor, Paul and Lafont, Yves},
title = {Proofs and Types},
year = 1989,
isbn = {0-521-37181-3},
publisher = {Cambridge University Press},
address = {New York, NY, USA},
}

@phdthesis{Girard1972PhD,
author = {Jean-Yves Girard},
title = {Interpr{\'e}tation fonctionnelle et {\'e}limination des coupures de l’arithm{\'e}tique d’ordre sup{\'e}rieur},
@type = {{Ph.D} thesis},
year = 1972,
school = {Universit{\'e} Paris 7},
}

@article{ArvindE88,
  author    = {Arvind and
               Kattamuri Ekanadham},
  title     = {Future Scientific Programming on Parallel Machines},
  journal   = {Journal of Parallel and Distribubted Computing},
  volume    = {5},
  number    = {5},
  pages     = {460--493},
  year      = {1988},
  @url       = {https://doi.org/10.1016/0743-7315(88)90009-3},
  doi       = {10.1016/0743-7315(88)90009-3},
}

@inproceedings{partain92,
  author    = {Will Partain},
  title     = {The nofib Benchmark Suite of {Haskell} Programs},
  booktitle = {Functional Programming, Glasgow 1992, Proceedings of the 1992 Glasgow
               Workshop on Functional Programming, Ayr, Scotland, UK, 6-8 July 1992},
  pages     = {195--202},
  year      = {1992},
}

@inproceedings{peytonJones89,
  author    = {Simon L. {Peyton Jones} and
               Jon Salkild},
  title     = {The Spineless Tagless {G}-Machine},
  booktitle = {Proceedings of the fourth international conference on Functional programming
               languages and computer architecture, {FPCA} 1989, London, UK, September
               11-13, 1989},
  pages     = {184--201},
  year      = 1989,
}

@inproceedings{sulzmann07,
  author    = {Martin Sulzmann and
               Manuel M. T. Chakravarty and
               Simon L. {Peyton Jones} and
               Kevin Donnelly},
  title     = {System {F} with type equality coercions},
  booktitle = {Proceedings of TLDI'07: 2007 {ACM} {SIGPLAN} International
                  Workshop on Types in Languages Design and Implementation,
                  Nice, France, January 16, 2007},
  pages     = {53--66},
  year      = 2007,
}

@article{Girard1987LL,
author = {Jean-Yves Girard},
title = {Linear logic},
journal = {Theoretical Computer Science},
volume = 50,
number = 1,
pages = {1--101},
year = 1987,
issn = {0304-3975},
doi = {10.1016/0304-3975(87)90045-4},
@url = {http://dx.doi.org/10.1016/0304-3975(87)90045-4},
abstract = {The familiar connective of negation is broken into two operations: linear negation which is the purely negative part of negation and the modality ``of course'' which has the meaning of a reaffirmation. Following this basic discovery, a completely new approach to the whole area between constructive logics and programmation is initiated.}
}

@article{Girard1991NCL,
title={A new constructive logic: classic logic},
volume={1}, DOI={10.1017/S0960129500001328},
number={3},
journal={Mathematical Structures in Computer Science},
publisher={Cambridge University Press},
author={Girard, Jean-Yves},
year={1991},
pages={255–296}
}

@article{DJS1997NDL,
author = {Danos, Vincent and Joinet, Jean-Baptiste and Schellinx, Harold},
title = {A New Deconstructive Logic: Linear Logic},
journal = {Journal of Symbolic Logic},
year = 1997,
volume = 62,
number = 3,
pages = {755–-807},
publisher = {Cambridge University Press},
doi = {10.2307/2275572},
@url = {http://dx.doi.org/10.2307/2275572},
}

@article{TaitsMethod,
 ISSN = {00224812},
 @URL = {http://www.jstor.org/stable/2271658},
 author = {W. W. Tait},
 journal = {The Journal of Symbolic Logic},
 number = {2},
 pages = {198--212},
 publisher = {Association for Symbolic Logic},
 title = {Intensional Interpretations of Functionals of Finite Type {I}},
 @urldate = {2024-07-19},
 volume = {32},
 year = {1967}
}


@InProceedings{MM2019ECBPV,
author="McDermott, Dylan
and Mycroft, Alan",
@editor="Caires, Lu{\'i}s",
title="Extended Call-by-Push-Value: Reasoning About Effectful Programs and Evaluation Order",
booktitle="Programming Languages and Systems",
year="2019",
publisher="Springer International Publishing",
address="Cham",
pages="235--262",
abstract="Traditionally, reasoning about programs under varying evaluation regimes (call-by-value, call-by-name etc.) was done at the meta-level, treating them as term rewriting systems. Levy's call-by-push-value (CBPV) calculus provides a more powerful approach for reasoning, by treating CBPV terms as a common intermediate language which captures both call-by-value and call-by-name, and by allowing equational reasoning about changes to evaluation order between or within programs.",
isbn="978-3-030-17184-1"
}

@article{AriolaFelleisen1997CBNLC,
author = {Ariola, Zena M. and Felleisen, Matthias},
title = {The Call-By-Need Lambda Calculus},
journal = {Journal of Functional Programming},
issue_date = {May 1997},
volume = 7,
number = 3,
@month = may,
year = 1997,
issn = {0956-7968},
pages = {265--301},
numpages = 37,
@url = {http://doi.acm.org/10.1145/199448.199507},
doi = {10.1017/S0956796897002724},
acmid = 969888,
publisher = {Cambridge University Press},
address = {New York, NY, USA},
}

@inproceedings{AriolaKlop1994CLGR,
  author    = {Zena M. Ariola and
               Jan Willem Klop},
  title     = {Cyclic Lambda Graph Rewriting},
  booktitle = {Proceedings of the Ninth Annual Symposium on Logic in Computer Science
               {(LICS}~'94), Paris, France, July 4-7, 1994},
  pages     = {416--425},
  year      = {1994},
  @url       = {https://doi.org/10.1109/LICS.1994.316066},
  doi       = {10.1109/LICS.1994.316066},
}

@article{BEPJW16,
  author    = {Joachim Breitner and
               Richard A. Eisenberg and
               Simon {Peyton Jones} and
               Stephanie Weirich},
  title     = {Safe zero-cost coercions for {Haskell}},
  journal   = {Journal of Functional Programming},
  volume    = {26},
  pages     = {e15},
  year      = {2016},
  @url       = {https://doi.org/10.1017/S0956796816000150},
  doi       = {10.1017/S0956796816000150},
}

@article{AriolaArvind95,
  author    = {Zena M. Ariola and
               Arvind},
  title     = {Properties of a First-Order Functional Language with Sharing},
  journal   = {Theoretical Computer Science},
  volume    = {146},
  number    = {1{\&}2},
  pages     = {69--108},
  year      = {1995},
  @url       = {https://doi.org/10.1016/0304-3975(94)00185-L},
  doi       = {10.1016/0304-3975(94)00185-L},
}

@inproceedings{Kay93,
  author    = {Alan C. Kay},
  title     = {The Early History of Smalltalk},
  booktitle = {HOPL Preprints},
  year      = {1993},
  pages     = {69-95},
  ee        = {http://doi.acm.org/10.1145/154766.155364},
}

@book{abadi96,
  author = {Abadi, Mart\'in and Cardelli, Luca},
  title = {A Theory of Objects},
  publisher = {Springer},
  year = {1996},
}

@phdthesis{CookPhD,
  author       = {William R. Cook},
  title        = {A denotational semantics of inheritance},
  school       = {Brown University, {USA}},
  year         = {1989},
  @url          = {https://cs.brown.edu/research/pubs/theses/phd/1989/cook.pdf},
}

@article{CookP94,
  author       = {William R. Cook and
                  Jens Palsberg},
  title        = {A Denotational Semantics of Inheritance and Its Correctness},
  journal      = {Information and Computation},
  volume       = {114},
  number       = {2},
  pages        = {329--350},
  year         = {1994},
  @url          = {https://doi.org/10.1006/inco.1994.1090},
  doi          = {10.1006/INCO.1994.1090},
  timestamp    = {Thu, 18 May 2017 09:54:17 +0200},
  bib@url       = {https://dblp.org/rec/journals/iandc/CookP94.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{CookHC90InheritanceNotSubtyping,
  author       = {William R. Cook and
                  Walter L. Hill and
                  Peter S. Canning},
  @editor       = {Frances E. Allen},
  title        = {Inheritance Is Not Subtyping},
  booktitle    = {Conference Record of the Seventeenth Annual {ACM} Symposium on Principles
                  of Programming Languages, San Francisco, California, USA, January
                  1990},
  pages        = {125--135},
  publisher    = {{ACM} Press},
  year         = {1990},
  @url          = {https://doi.org/10.1145/96709.96721},
  doi          = {10.1145/96709.96721},
  timestamp    = {Wed, 14 Nov 2018 10:52:34 +0100},
  bib@url       = {https://dblp.org/rec/conf/popl/CookHC90.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{Cook92Smalltalk,
  author       = {William R. Cook},
  @editor       = {John R. Pugh},
  title        = {Interfaces and Specifications for the Smalltalk-80 Collection Classes},
  booktitle    = {Proceedings of the Seventh Annual Conference on Object-Oriented Programming
                  Systems, Languages, and Applications, {OOPSLA} 1992, Vancouver, British
                  Columbia, Canada, October 18-22, 1992},
  pages        = {1--15},
  publisher    = {{ACM}},
  year         = {1992},
  @url          = {https://doi.org/10.1145/141936.141938},
  doi          = {10.1145/141936.141938},
  timestamp    = {Fri, 13 May 2022 10:38:22 +0200},
  bib@url       = {https://dblp.org/rec/conf/oopsla/Cook92.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{BrachaC90Mixins,
  author       = {Gilad Bracha and
                  William R. Cook},
  @editor       = {Akinori Yonezawa},
  title        = {Mixin-based Inheritance},
  booktitle    = {Conference on Object-Oriented Programming Systems, Languages, and
                  Applications / European Conference on Object-Oriented Programming,
                  {OOPSLA/ECOOP} 1990, Ottawa, Canada, October 21-25, 1990, Proceedings},
  pages        = {303--311},
  publisher    = {{ACM}},
  year         = {1990},
  @url          = {https://doi.org/10.1145/97945.97982},
  doi          = {10.1145/97945.97982},
  timestamp    = {Wed, 30 Mar 2022 13:54:42 +0200},
  bib@url       = {https://dblp.org/rec/conf/oopsla/BrachaC90.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{flatt1998mixin,
  title={Classes and mixins},
  author={Flatt, Matthew and Krishnamurthi, Shriram and Felleisen, Matthias},
  booktitle={Proceedings of the 25th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  pages={171--183},
  year={1998}
}

@inproceedings{Ingalls86,
author = {Ingalls, Daniel H. H.},
title = {A simple technique for handling multiple polymorphism},
year = {1986},
isbn = {0897912047},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/28697.28732},
doi = {10.1145/28697.28732},
abstract = {Certain situations arise in programming that lead to multiply polymorphic expressions, that is, expressions in which several terms may each be of variable type. In such situations, conventional object-oriented programming practice breaks down, leading to code which is not properly modular. This paper describes a simple approach to such problems which preserves all the benefits of good object-oriented programming style in the face of any degree of polymorphism. An example is given in Smalltalk-80 syntax, but the technique is relevant to all object-oriented languages.},
booktitle = {Conference Proceedings on Object-Oriented Programming Systems, Languages and Applications},
pages = {347–349},
numpages = {3},
location = {Portland, Oregon, USA},
series = {OOPSLA~'86}
}

@inproceedings{chambers1992,
  title={Object-oriented multi-methods in {C}ecil},
  author={Chambers, Craig},
  booktitle={European Conference on Object-Oriented Programming},
  pages={33--56},
  year={1992},
  organization={Springer}
}

@article{CLOS,
author = {Gabriel, Richard and White, Jon and Bobrow, Daniel},
year = {1991},
@month = {09},
pages = {28-38},
title = {CLOS: Integrating Object-Oriented and Functional Programming.},
volume = {34},
journal = {Communications of the ACM},
doi = {10.1145/114669.114671}
}

@inproceedings{VirtualClassCalculus,
author = {Ernst, Erik and Ostermann, Klaus and Cook, William R.},
title = {A virtual class calculus},
year = {2006},
isbn = {1595930272},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/1111037.1111062},
doi = {10.1145/1111037.1111062},
abstract = {Virtual classes are class-valued attributes of objects. Like virtual methods, virtual classes are defined in an object's class and may be redefined within subclasses. They resemble inner classes, which are also defined within a class, but virtual classes are accessed through object instances, not as static components of a class. When used as types, virtual classes depend upon object identity -- each object instance introduces a new family of virtual class types. Virtual classes support large-scale program composition techniques, including higher-order hierarchies and family polymorphism. The original definition of virtual classes in BETA left open the question of static type safety, since some type errors were not caught until runtime. Later the languages Caesar and gbeta have used a more strict static analysis in order to ensure static type safety. However, the existence of a sound, statically typed model for virtual classes has been a long-standing open question. This paper presents a virtual class calculus, VC, that captures the essence of virtual classes in these full-fledged programming languages. The key contributions of the paper are a formalization of the dynamic and static semantics of VC and a proof of the soundness of VC.},
booktitle = {Conference Record of the 33rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {270–282},
numpages = {13},
keywords = {virtual classes, soundness},
location = {Charleston, South Carolina, USA},
series = {POPL~'06}
}

@inproceedings{Ostermann2001OOComposition,
author = {Ostermann, Klaus and Mezini, Mira},
title = {Object-oriented composition untangled},
year = 2001,
isbn = 1581133359,
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/504282.504303},
doi = {10.1145/504282.504303},
abstract = {Object-oriented languages come with pre-defined composition mechansims, such as inheritance, object composition, or delegation, each characterized by a certain set of composition properties, which do not themselves individually exist as abstractions at the language level. However, often non-standard composition semantics is needed, with a mixture of composition mechanisms. Such non-standard semantics are simulated by complicated architectures that are sensitive to requirement changes and cannot easily be adapted without invalidating existing clients. In this paper, we propose compound references, a new abstraction for object references, that allows us to provide explicit linguistic means for expressing and combining individual composition properties on-demand. The model is statically typed and allows the programmer to express a seamless spectrum of composition semantics in the interval between object composition and inheritance. The resulting programs are better understandable, due to explicity expressed design decisions, and less sensitive to requirement changes.},
booktitle = {Proceedings of the 16th ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications},
pages = {283–299},
numpages = 17,
location = {Tampa Bay, FL, USA},
series = {OOPSLA~'01}
}


@misc{Harper11PC,
author = {Robert Harper},
title = {Parallelism is not Concurrency},
@journal = {Existential Type},
@month = mar,
year = 2011,
@url = {https://existentialtype.wordpress.com/2011/03/17/parallelism-is-not-concurrency/},
}

@misc{Marlow09PC,
author = {Simon Marlow},
title = {Parallelism {$\neq$} Concurrency},
@journal = {{GHC} Mutterings},
@month = oct,
year = 2009,
@url = {https://ghcmutterings.wordpress.com/2009/10/06/parallelism-concurrency/},
}

@inproceedings{Turon2015RPL,
author = {Aaron Turon},
title = {The {Rust} programming language},
booktitle = {The 4th ACM SIGPLAN Workshop on Higher-Order Programming with Effects},
series = {HOPE~'15},
year = 2015,
@month = aug,
}

@inproceedings{Turon17,
  author    = {Aaron Turon},
  title     = {Rust: from {POPL} to practice (keynote)},
  booktitle = {Proceedings of the 44th {ACM} {SIGPLAN} Symposium on Principles of
               Programming Languages, {POPL} 2017, Paris, France, January 18-20,
               2017},
  pages     = {2},
  year      = {2017},
  @url       = {http://dl.acm.org/citation.cfm?id=3011999},
}

@inproceedings{GMJHWC02RBMMC,
  author    = {Dan Grossman and
               J. Gregory Morrisett and
               Trevor Jim and
               Michael W. Hicks and
               Yanling Wang and
               James Cheney},
  title     = {Region-Based Memory Management in Cyclone},
  booktitle = {Proceedings of the 2002 {ACM} {SIGPLAN} Conference on Programming
               Language Design and Implementation (PLDI), Berlin, Germany, June 17-19,
               2002},
  pages     = {282--293},
  year      = {2002},
  @url       = {https://doi.org/10.1145/512529.512563},
  doi       = {10.1145/512529.512563},
}

@inproceedings{Honda93TDI,
  author    = {Kohei Honda},
  title     = {Types for Dyadic Interaction},
  booktitle = {{CONCUR}~'93, 4th International Conference on Concurrency Theory,
               Hildesheim, Germany, August 23-26, 1993, Proceedings},
  pages     = {509--523},
  year      = {1993},
  @url       = {https://doi.org/10.1007/3-540-57208-2\_35},
  doi       = {10.1007/3-540-57208-2\_35},
}

@article{Wadler14PAS,
  author    = {Philip Wadler},
  title     = {Propositions as Sessions},
  journal   = {Journal of Functional Programming},
  volume    = {24},
  number    = {2-3},
  pages     = {384--418},
  year      = {2014},
  @url       = {https://doi.org/10.1017/S095679681400001X},
  doi       = {10.1017/S095679681400001X},
}

@inproceedings{CairesP10STLP,
  author    = {Lu{\'{\i}}s Caires and
               Frank Pfenning},
  title     = {Session Types as Intuitionistic Linear Propositions},
  booktitle = {{CONCUR} 2010 - Concurrency Theory, 21th International Conference,
               {CONCUR} 2010, Paris, France, August 31-September 3, 2010. Proceedings},
  pages     = {222--236},
  year      = {2010},
  @url       = {https://doi.org/10.1007/978-3-642-15375-4\_16},
  doi       = {10.1007/978-3-642-15375-4\_16},
}

@article{GayV10LTTAST,
  author    = {Simon J. Gay and
               Vasco Thudichum Vasconcelos},
  title     = {Linear type theory for asynchronous session types},
  journal   = {Journal of Functional Programming},
  volume    = {20},
  number    = {1},
  pages     = {19--50},
  year      = {2010},
  @url       = {https://doi.org/10.1017/S0956796809990268},
  doi       = {10.1017/S0956796809990268},
}

@article{HYC2016MAST,
 author = {Honda, Kohei and Yoshida, Nobuko and Carbone, Marco},
 title = {Multiparty Asynchronous Session Types},
 journal = {Journal of the {ACM}},
 issue_date = {March 2016},
 volume = {63},
 number = {1},
 @month = mar,
 year = {2016},
 issn = {0004-5411},
 pages = {9:1--9:67},
 articleno = {9},
 numpages = {67},
 @url = {http://doi.acm.org/10.1145/2827695},
 doi = {10.1145/2827695},
 acmid = {2827695},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Session types, global protocols, global types, progress, projection, the pi-calculus},
}

@inproceedings{BalzerPfenning2015,
  author       = {Stephanie Balzer and
                  Frank Pfenning},
  @editor       = {Elisa Gonzalez Boix and
                  Philipp Haller and
                  Alessandro Ricci and
                  Carlos A. Varela},
  title        = {Objects as session-typed processes},
  booktitle    = {Proceedings of the 5th International Workshop on Programming Based
                  on Actors, Agents, and Decentralized Control, AGERE! 2015, Pittsburgh,
                  PA, USA, October 26, 2015},
  pages        = {13--24},
  publisher    = {{ACM}},
  year         = {2015},
  @url          = {https://doi.org/10.1145/2824815.2824817},
  doi          = {10.1145/2824815.2824817},
}

@article{BP2017ManifestSharing,
  author       = {Stephanie Balzer and
                  Frank Pfenning},
  title        = {Manifest sharing with session types},
  journal      = {Proceedings of the {ACM} on Programming Languages},
  volume       = {1},
  number       = {{ICFP}},
  pages        = {37:1--37:29},
  year         = {2017},
  @url          = {https://doi.org/10.1145/3110281},
  doi          = {10.1145/3110281},
}

@inproceedings{BPT18UniversalSessionType,
  author       = {Stephanie Balzer and
                  Frank Pfenning and
                  Bernardo Toninho},
  @editor       = {Sven Schewe and
                  Lijun Zhang},
  title        = {A Universal Session Type for Untyped Asynchronous Communication},
  booktitle    = {29th International Conference on Concurrency Theory, {CONCUR} 2018,
                  September 4-7, 2018, Beijing, China},
  series       = {LIPIcs},
  volume       = {118},
  pages        = {30:1--30:18},
  publisher    = {Schloss Dagstuhl - Leibniz-Zentrum f{\"{u}}r Informatik},
  year         = {2018},
  @url          = {https://doi.org/10.4230/LIPIcs.CONCUR.2018.30},
  doi          = {10.4230/LIPICS.CONCUR.2018.30},
}

@article{ChenBT22Ferrite,
  author       = {Ruofei Chen and
                  Stephanie Balzer and
                  Bernardo Toninho},
  title        = {Ferrite: {A} Judgmental Embedding of Session Types in Rust (Artifact)},
  journal      = {Dagstuhl Artifacts Series},
  volume       = {8},
  number       = {2},
  pages        = {14:1--14:2},
  year         = {2022},
  @url          = {https://doi.org/10.4230/DARTS.8.2.14},
  doi          = {10.4230/DARTS.8.2.14},
}

@inproceedings{SanoBP21Phased,
  author       = {Chuta Sano and
                  Stephanie Balzer and
                  Frank Pfenning},
  @editor       = {Ferruccio Damiani and
                  Ornela Dardha},
  title        = {Manifestly Phased Communication via Shared Session Types},
  booktitle    = {Coordination Models and Languages - 23rd {IFIP} {WG} 6.1 International
                  Conference, {COORDINATION} 2021, Held as Part of the 16th International
                  Federated Conference on Distributed Computing Techniques, DisCoTec
                  2021, Valletta, Malta, June 14-18, 2021, Proceedings},
  @series       = {Lecture Notes in Computer Science},
  volume       = {12717},
  pages        = {23--40},
  publisher    = {Springer},
  year         = {2021},
  @url          = {https://doi.org/10.1007/978-3-030-78142-2\_2},
  doi          = {10.1007/978-3-030-78142-2\_2},
}

@article{das2022rast,
  title={Rast: A language for resource-aware session types},
  author={Das, Ankush and Pfenning, Frank},
  journal={Logical Methods in Computer Science},
  volume={18},
  year={2022},
  publisher={Episciences. org},
	@url={https://doi.org/10.46298/lmcs-18(1:9)2022},
}

@article{DDMP2022NestedSessionTypes,
author = {Das, Ankush and Deyoung, Henry and Mordido, Andreia and Pfenning, Frank},
title = {Nested Session Types},
year = {2022},
issue_date = {September 2022},
publisher = {ACM},
address = {New York, NY, USA},
volume = {44},
number = {3},
issn = {0164-0925},
@url = {https://doi.org/10.1145/3539656},
doi = {10.1145/3539656},
abstract = {Session types statically describe communication protocols between concurrent message-passing processes. Unfortunately, parametric polymorphism even in its restricted prenex form is not fully understood in the context of session types. In this article, we present the metatheory of session types extended with prenex polymorphism and, as a result, nested recursive datatypes. Remarkably, we prove that type equality is decidable by exhibiting a reduction to trace equivalence of deterministic first-order grammars. Recognizing the high theoretical complexity of the latter, we also propose a novel type equality algorithm and prove its soundness. We observe that the algorithm is surprisingly efficient and, despite its incompleteness, sufficient for all our examples. We have implemented our ideas by extending the Rast programming language with nested session types. We conclude with several examples illustrating the expressivity of our enhanced type system.},
journal = {ACM Trans. Program. Lang. Syst.},
@month = {jul},
articleno = {19},
numpages = {45},
keywords = {Nested types, polymorphism, type equality}
}

@inproceedings{BalzerTP19DeadlockFree,
  author       = {Stephanie Balzer and
                  Bernardo Toninho and
                  Frank Pfenning},
  @editor       = {Lu{\'{\i}}s Caires},
  title        = {Manifest Deadlock-Freedom for Shared Session Types},
  booktitle    = {Programming Languages and Systems - 28th European Symposium on Programming,
                  {ESOP} 2019, Held as Part of the European Joint Conferences on Theory
                  and Practice of Software, {ETAPS} 2019, Prague, Czech Republic, April
                  6-11, 2019, Proceedings},
  @series       = {Lecture Notes in Computer Science},
  volume       = {11423},
  pages        = {611--639},
  publisher    = {Springer},
  year         = {2019},
  @url          = {https://doi.org/10.1007/978-3-030-17184-1\_22},
  doi          = {10.1007/978-3-030-17184-1\_22},
}

@inproceedings{DBJ2021Noninterference,
  author       = {Farzaneh Derakhshan and
                  Stephanie Balzer and
                  Limin Jia},
  title        = {Session Logical Relations for Noninterference},
  booktitle    = {36th Annual {ACM/IEEE} Symposium on Logic in Computer Science, {LICS}
                  2021, Rome, Italy, June 29 - July 2, 2021},
  pages        = {1--14},
  publisher    = {{IEEE}},
  year         = {2021},
  @url          = {https://doi.org/10.1109/LICS52264.2021.9470654},
  doi          = {10.1109/LICS52264.2021.9470654},
}

@article{JacobsB23HODeadlockFree,
  author       = {Jules Jacobs and
                  Stephanie Balzer},
  title        = {Higher-Order Leak and Deadlock Free Locks},
  journal      = {Proceedings of the {ACM} on Programming Languages},
  volume       = {7},
  number       = {{POPL}},
  pages        = {1027--1057},
  year         = {2023},
  @url          = {https://doi.org/10.1145/3571229},
  doi          = {10.1145/3571229},
}

@article{MoineWB24DisLog,
  author       = {Alexandre Moine and
                  Sam Westrick and
                  Stephanie Balzer},
  title        = {DisLog: {A} Separation Logic for Disentanglement},
  journal      = {Proceedings of the {ACM} on Programming Languages},
  volume       = {8},
  number       = {{POPL}},
  pages        = {302--331},
  year         = {2024},
  @url          = {https://doi.org/10.1145/3632853},
  doi          = {10.1145/3632853},
}

@inproceedings{ObjectPropositions,
  author       = {Ligia Nistor and
                  Jonathan Aldrich and
                  Stephanie Balzer and
                  Hannes Mehnert},
  @editor       = {Cliff B. Jones and
                  Pekka Pihlajasaari and
                  Jun Sun},
  title        = {Object Propositions},
  booktitle    = {{FM} 2014: Formal Methods - 19th International Symposium, Singapore,
                  May 12-16, 2014. Proceedings},
  @series       = {Lecture Notes in Computer Science},
  volume       = {8442},
  pages        = {497--513},
  publisher    = {Springer},
  year         = {2014},
  @url          = {https://doi.org/10.1007/978-3-319-06410-9\_34},
  doi          = {10.1007/978-3-319-06410-9\_34},
}

@article{Parnas1972CUD,
 author = {Parnas, D. L.},
 title = {On the Criteria to Be Used in Decomposing Systems into Modules},
 journal = {Communications of the ACM},
 issue_date = {Dec. 1972},
 volume = {15},
 number = {12},
 @month = dec,
 year = {1972},
 issn = {0001-0782},
 pages = {1053--1058},
 numpages = {6},
 @url = {http://doi.acm.org/10.1145/361598.361623},
 doi = {10.1145/361598.361623},
 acmid = {361623},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {KWIC index, modularity, modules, software, software design, software engineering},
} 

@book{Pierce2002TPL,
author = {Pierce, Benjamin C.},
title = {Types and Programming Languages},
year = 2002,
publisher = {The MIT Press},
address = {Cambridge, Massachusetts},
isbn = 9780262162098,
}

@book{Mitchell2001CPL,
 author = {Mitchell, John C. and Apt, Krzysztof},
 title = {Concepts in Programming Languages},
 year = {2001},
 isbn = {0521780985},
 publisher = {Cambridge University Press},
 address = {New York, NY, USA},
}

@book{Mitchell1996FPL,
 author = {Mitchell, John C.},
 title = {Foundations for Programming Languages},
 year = {1996},
 isbn = {9780262133210},
 publisher = {The MIT Press},
 address = {Cambridge, MA, USA},
}

@book{Harper2012PFPL,
 author = {Harper, Robert},
 title = {Practical Foundations for Programming Languages},
 year = {2012},
 isbn = {1107029570, 9781107029576},
 publisher = {Cambridge University Press},
 address = {Cambridge, MA, USA},
}

@book{Gunter1992SPL,
 author = {Gunter, Carl A.},
 title = {Semantics of Programming Languages: Structures and Techniques},
 year = {1992},
 isbn = {9780262570954},
 publisher = {The MIT Press},
 address = {Cambridge, MA, USA},
}

@article{Barendregt1974PWCR,
  title={Pairing without conventional restraints},
  author={Barendregt, Henk},
  journal={Mathematical Logic Quarterly},
  volume={20},
  number={19-22},
  pages={289--306},
  year={1974},
  publisher={Wiley Online Library}
}

@article{Church1932SPFL,
author = {Church, Alonzo},
title = {A Set of Postulates for the Foundation of Logic},
journal = {Annals of Mathematics},
year = 1932,
number = 2,
volume = 33,
pages = {346--366},
numpages = 21,
doi = {10.2307/1968337},
@url = {http://dx.doi.org/10.2307/1968337},
}

@article{Gentzen1935UULS1,
author = {Gentzen, Gerhard},
title = {Untersuchungen {\"u}ber das logische Schlie{\ss}en. {I}},
journal = {Mathematische Zeitschrift},
year = 1935,
volume = 39,
number = 1,
pages = {176-210},
numpages = 35,
issn = {0025-5874},
doi = {10.1007/BF01201353},
@url = {http://dx.doi.org/10.1007/BF01201353},
}

@article{Gentzen1935UULS2,
author = {Gentzen, Gerhard},
title = {Untersuchungen {\"u}ber das logische Schlie{\ss}en. {II}},
journal = {Mathematische Zeitschrift},
year = 1935,
volume = 39,
number = 1,
pages = {405-431},
numpages = 27,
issn = {0025-5874},
doi = {10.1007/BF01201363},
@url = {http://dx.doi.org/10.1007/BF01201363},
}

@book{brouwer1907,
  title={Over de grondslagen der wiskunde},
  author={Brouwer, Luitzen Egbertus Jan},
  year={1907},
  publisher={Maas \& van Suchtelen}
}

@book{brouwer1908,
  title={Die onbetrouwbaarheid der logische principes},
  author={Brouwer, Luitzen Egbertus Jan},
  year={1908},
  publisher={P. Noordhoff}
}

@incollection{Dummett1991LBM,
author = {Michael Dummett},
title = {The Logical Basis of Methaphysics},
booktitle = {The {William James} Lectures, 1976},
publisher =  {Harvard University Press, Cambridge, Massachusetts},
year = 1991,
isbn = 9780674537866,
}

@inproceedings{Parigot1992LMC,
author = {Parigot, Michel},
@editor = {Voronkov, Andrei},
title = {{$\lambda\mu$}-Calculus: An Algorithmic Interpretation of Classical Natural Deduction},
bookTitle = {Logic Programming and Automated Reasoning: International Conference},
series = {LPAR~'92},
location = {St. Petersburg, Russia},
@month = jul,
year = 1992,
publisher = {Springer Berlin Heidelberg},
address = {Berlin, Heidelberg},
pages = {190--201},
isbn = {978-3-540-47279-7},
doi = {10.1007/BFb0013061},
@url = {http://dx.doi.org/10.1007/BFb0013061},
}

@inproceedings{Copatterns,
author = {Abel, Andreas and Pientka, Brigitte and Thibodeau, David and Setzer, Anton},
title = {Copatterns: Programming Infinite Structures by Observations},
booktitle = {Proceedings of the 40th Annual {ACM} {SIGPLAN-SIGACT} Symposium on Principles of Programming Languages},
series = {POPL~'13},
year = 2013,
isbn = {978-1-4503-1832-7},
location = {Rome, Italy},
pages = {27--38},
numpages = 12,
@url = {http://doi.acm.org/10.1145/2429069.2429075},
doi = {10.1145/2429069.2429075},
acmid = 2429075,
publisher = {ACM},
address = {New York, NY, USA},
keywords = {coinduction, functional programming, introduction vs. elimination, message passing, pattern matching},
}

@inproceedings{AbelPientka2013WRC,
author = {Abel, Andreas M. and Pientka, Brigitte},
title = {Wellfounded Recursion with Copatterns: A Unified Approach to Termination and Productivity},
booktitle = {Proceedings of the 18th {ACM} {SIGPLAN} International Conference on Functional Programming},
series = {ICFP~'13},
year = {2013},
isbn = {978-1-4503-2326-0},
location = {Boston, Massachusetts, USA},
pages = {185--196},
numpages = {12},
@url = {http://doi.acm.org/10.1145/2500365.2500591},
doi = {10.1145/2500365.2500591},
acmid = {2500591},
publisher = {ACM},
address = {New York, NY, USA},
keywords = {coinduction, pattern matching, productivity, recursion, strong normalization, type-based termination},
}

@article{ABEL_PIENTKA_2016,
title={Well-founded recursion with copatterns and sized types},
volume={26},
DOI={10.1017/S0956796816000022},
@url={https://doi.org/10.1017/S0956796816000022},
journal={Journal of Functional Programming},
author={Abel, Andreas and Pientka, Brigitte},
year={2016},
pages={e2},
}

@Inproceedings{AbelChapman2014NBE,
  author    = {Abel, Andreas and Chapman, James},
  year      = {2014},
  title     = {Normalization by Evaluation in the Delay Monad: A Case Study for Coinduction via Copatterns and Sized Types},
  @editor    = {Levy, Paul and Krishnaswami, Neel },
  booktitle = {{\rm Proceedings 5th Workshop on}
               Mathematically Structured Functional Programming,
               {\rm Grenoble, France, 12 April 2014}},
  series    = {Electronic Proceedings in Theoretical Computer Science},
  volume    = {153},
  publisher = {Open Publishing Association},
  pages     = {51-67},
  doi       = {10.4204/EPTCS.153.4},
	@url       = {https://doi.org/10.4204/EPTCS.153.4},
}

@inproceedings{InfiniteStructuresCopatterns,
  author       = {Andreas Abel},
  @editor       = {Klaus Schmid and
                  Wolfgang B{\"{o}}hm and
                  Robert Heinrich and
                  Andrea Herrmann and
                  Anne Hoffmann and
                  Dieter Landes and
                  Marco Konersmann and
                  Thomas Ruhroth and
                  Oliver Sander and
                  Volker Stolz and
                  Baltasar Tranc{\'{o}}n y Widemann and
                  R{\"{u}}diger Wei{\ss}bach},
  title        = {Programming and Reasoning with Infinite Structures Using Copatterns
                  and Sized Types},
  booktitle    = {Gemeinsamer Tagungsband der Workshops der Tagung Software Engineering
                  2014, 25.-26. Februar 2014 in Kiel, Deutschland},
  series       = {{CEUR} Workshop Proceedings},
  volume       = {1129},
  pages        = {148--150},
  publisher    = {CEUR-WS.org},
  year         = {2014},
  @url          = {https://ceur-ws.org/Vol-1129/paper46.pdf},
}

@inproceedings{UnnestingCopatterns,
  author    = {Anton Setzer and
               Andreas Abel and
               Brigitte Pientka and
               David Thibodeau},
  @editor    = {Gilles Dowek},
  title     = {Unnesting of Copatterns},
  booktitle = {Rewriting and Typed Lambda Calculi - Joint International Conference,
               {RTA-TLCA} 2014, Held as Part of the Vienna Summer of Logic,
							 Vienna, Austria, July 14-17, 2014. Proceedings},
  @series    = {Lecture Notes in Computer Science},
  volume    = {8560},
  pages     = {31--45},
  publisher = {Springer},
  address   = {Cham},
  year      = {2014},
  @url       = {https://doi.org/10.1007/978-3-319-08918-8\_3},
  doi       = {10.1007/978-3-319-08918-8\_3},
}

@article{ElaboratingDependentCopatterns,
author = {Cockx, Jesper and Abel, Andreas},
title = {Elaborating dependent (co)pattern matching},
year = {2018},
issue_date = {September 2018},
publisher = {ACM},
address = {New York, NY, USA},
volume = {2},
number = {ICFP},
@url = {https://doi.org/10.1145/3236770},
doi = {10.1145/3236770},
abstract = {In a dependently typed language, we can guarantee correctness of our programs by providing formal proofs. To check them, the typechecker elaborates these programs and proofs into a low level core language. However, this core language is by nature hard to understand by mere humans, so how can we know we proved the right thing? This question occurs in particular for dependent copattern matching, a powerful language construct for writing programs and proofs by dependent case analysis and mixed induction/coinduction. A definition by copattern matching consists of a list of clauses that are elaborated to a case tree, which can be further translated to primitive eliminators. In previous work this second step has received a lot of attention, but the first step has been mostly ignored so far. We present an algorithm elaborating definitions by dependent copattern matching to a core language with inductive datatypes, coinductive record types, an identity type, and constants defined by well-typed case trees. To ensure correctness, we prove that elaboration preserves the first-match semantics of the user clauses. Based on this theoretical work, we reimplement the algorithm used by Agda to check left-hand sides of definitions by pattern matching. The new implementation is at the same time more general and less complex, and fixes a number of bugs and usability issues with the old version. Thus we take another step towards the formally verified implementation of a practical dependently typed language.},
journal = {Proceedings of the ACM on Programming Languages},
@month = {jul},
articleno = {75},
numpages = {30},
keywords = {Dependent types, Dependent pattern matching, Copatterns, Agda}
}

@inproceedings{ThibodeauCP2016ICT,
  author    = {David Thibodeau and
               Andrew Cave and
               Brigitte Pientka},
  title     = {Indexed codata types},
  booktitle = {Proceedings of the 21st {ACM} {SIGPLAN} International Conference on
               Functional Programming, {ICFP} 2016, Nara, Japan, September 18-22,
               2016},
  pages     = {351--363},
  year      = {2016},
  @url       = {https://doi.org/10.1145/2951913.2951929},
  doi       = {10.1145/2951913.2951929},
}

@phdthesis{ThibodeauPhD,
  author = {Thibodeau, David},
  title  = {An Intensional Type Theory of Coinduction using Copatterns},
  school = {School of Computer Science, Mcgill University, Montreal},
  year   = {2020},
}

@mastersthesis{ThibodeauMasters,
  author = {Thibodeau, David},
  title  = {Programming Infinite Structures using Copatterns},
  school = {School of Computer Science, Mcgill University, Montreal},
  year   = {2015},
}

@article{Gibbons2021HTDcoP,
  author       = {Jeremy Gibbons},
  title        = {How to design co-programs},
  journal      = {Journal of Functional Programming},
  volume       = {31},
  pages        = {e15},
  year         = {2021},
  @url          = {https://doi.org/10.1017/S0956796821000113},
  doi          = {10.1017/S0956796821000113},
}

@article{PeytonJones1992ILFLSH,
title={Implementing lazy functional languages on stock hardware: the Spineless Tagless G-machine},
volume={2},
DOI={10.1017/S0956796800000319},
number={2},
journal={Journal of Functional Programming},
publisher={Cambridge University Press},
author={Jones, Simon L. Peyton},
year={1992},
pages={127–202}
}

@inproceedings{Zeilberger2008FHOAS,
author = {Zeilberger, Noam},
title = {Focusing and Higher-Order Abstract Syntax},
booktitle = {Proceedings of the 35th Annual {ACM} {SIGPLAN-SIGACT} Symposium on Principles of Programming Languages},
series = {POPL~'08},
year = 2008,
isbn = {978-1-59593-689-9},
location = {San Francisco, California, USA},
pages = {359--369},
numpages = 11,
@url = {http://doi.acm.org/10.1145/1328438.1328482},
doi = {10.1145/1328438.1328482},
acmid = 1328482,
publisher = {ACM},
address = {New York, NY, USA},
keywords = {focusing, higher-order abstract syntax, pattern-matching},
}

@article{Zeilberger2008OUD,
author = {Noam Zeilberger},
title = {On the Unity of Duality},
journal = {Annals of Pure and Applied Logic},
volume = 153,
number = 1,
pages = {660--96},
year = 2008,
issn = {0168-0072},
doi = {10.1016/j.apal.2008.01.001},
@url = {http://dx.doi.org/10.1016/j.apal.2008.01.001},
keywords = {Polarity, Focusing, Evaluation order, Michael Dummett, Curry–Howard isomorphism},
abstract = {Most type systems are agnostic regarding the evaluation strategy for the underlying languages, with the value restriction for ML which is absent in Haskell as a notable exception. As type systems become more precise, however, detailed properties of the operational semantics may become visible because properties captured by the types may be sound under one strategy but not the other. For example, intersection types distinguish between call-by-name and call-by-value functions, because the subtyping law (A→B)∩(A→C)≤A→(B∩C) is unsound for the latter in the presence of effects. In this paper we develop a proof-theoretic framework for analyzing the interaction of types with evaluation order, based on the notion of polarity. Polarity was discovered through linear logic, but we propose a fresh origin in Dummett’s program of justifying the logical laws through alternative verificationist or pragmatist “meaning-theories”, which include a bias towards either introduction or elimination rules. We revisit Dummett’s analysis using the tools of Martin-Löf’s judgmental method, and then show how to extend it to a unified polarized logic, with Girard’s “shift” connectives acting as intermediaries. This logic safely combines intuitionistic and dual intuitionistic reasoning principles, while simultaneously admitting a focusing interpretation for the classical sequent calculus. Then, by applying the Curry–Howard isomorphism to polarized logic, we obtain a single programming language in which evaluation order is reflected at the level of types. Different logical notions correspond directly to natural programming constructs, such as pattern-matching, explicit substitutions, values and call-by-value continuations. We give examples demonstrating the expressiveness of the language and type system, and prove a basic but modular type safety result. We conclude with a brief discussion of extensions to the language with additional effects and types, and sketch the sort of explanation this can provide for operationally sensitive typing phenomena.}
}

@inproceedings{Zeilberger2010PLDC,
  author       = {Noam Zeilberger},
  title        = {Polarity and the Logic of Delimited Continuations},
  booktitle    = {Proceedings of the 25th Annual {IEEE} Symposium on Logic in Computer
                  Science, {LICS} 2010, 11-14 July 2010, Edinburgh, United Kingdom},
  pages        = {219--227},
  publisher    = {{IEEE} Computer Society},
  year         = {2010},
  @url          = {https://doi.org/10.1109/LICS.2010.23},
  doi          = {10.1109/LICS.2010.23},
}

@inproceedings{MelliesZeilberger2015FTRS,
  author       = {Paul{-}Andr{\'{e}} Melli{\`{e}}s and
                  Noam Zeilberger},
  @editor       = {Sriram K. Rajamani and
                  David Walker},
  title        = {Functors are Type Refinement Systems},
  booktitle    = {Proceedings of the 42nd Annual {ACM} {SIGPLAN-SIGACT} Symposium on
                  Principles of Programming Languages, {POPL} 2015, Mumbai, India, January
                  15-17, 2015},
  pages        = {3--16},
  publisher    = {{ACM}},
  year         = {2015},
  @url          = {https://doi.org/10.1145/2676726.2676970},
  doi          = {10.1145/2676726.2676970},
}

@phdthesis{Zeilberger2009PhD,
author = {Noam Zeilberger},
title  = {The Logical Basis of Evaluation Order and Pattern-Matching},
school = {Carnegie Mellon University},
year   = {2009}
}

@inproceedings{MunchMaccagnoni2009FCR,
author = {Munch-Maccagnoni, Guillaume},
title = {Focalisation and Classical Realisability},
bookTitle = {Computer Science Logic: 23rd international Workshop, {CSL} 2009, 18th Annual Conference of the {EACSL}},
series = {CSL 2009},
location = {Coimbra, Portugal},
@month = sep,
year = 2009,
@editor = {Gr{\"a}del, Erich and Kahle, Reinhard},
publisher = {Springer Berlin Heidelberg},
address = {Berlin, Heidelberg},
pages = {409--423},
isbn = {978-3-642-04027-6},
doi = {10.1007/978-3-642-04027-6_30},
@url = {http://dx.doi.org/10.1007/978-3-642-04027-6_30}
}

@inproceedings{CurienMunchMaccagnoni2010DCUF,
author = {Curien, Pierre-Louis and Munch-Maccagnoni, Guillaume},
title = {The Duality of Computation Under Focus},
bookTitle = {Theoretical Computer Science: 6th {IFIP TC 1/WG} 2.2 International Conference, {TCS} 2010, Held as Part of {WCC} 2010},
series = {TCS 2010},
location = {Brisbane, Australia},
@month = sep,
year = 2010,
@editor = {Calude, Cristian S. and Sassone, Vladimiro},
publisher = {Springer Berlin Heidelberg},
address = {Berlin, Heidelberg},
pages = {165--181},
isbn = {978-3-642-15240-5},
doi = {10.1007/978-3-642-15240-5_13},
@url = {http://dx.doi.org/10.1007/978-3-642-15240-5_13}
}

@PhdThesis{MunchMaccagnoni2013PhD,
Title = {Syntax and Models of a non-Associative Composition of Programs and Proofs},
Author = {Munch-Maccagnoni, Guillaume},
School = {Universit\'e Paris Diderot},
Year = 2013,
}

@inproceedings{MunchMaccagnoniSherer2015PIRLCS,
author = {Guillaume Munch-Maccagnoni and Gabriel Scherer},
booktitle = {2015 30th Annual {ACM}/{IEEE} Symposium on Logic in Computer Science},
title = {Polarised Intermediate Representation of Lambda Calculus with Sums},
series = {LICS 2015},
location = {Kyoto, Japan},
@month = jul,
year = 2015,
pages = {127--140},
ISSN = {1043-6871},
doi = {10.1109/LICS.2015.22},
@url = {http://dx.doi.org/10.1109/LICS.2015.22},
keywords = {lambda calculus;λ-calculus theory;extensional sums;intermediate calculus;lambda calculus;polarised intermediate representation;sums;syntax directed algorithm;transition rule;Boolean functions;Computer science;Data structures;Global Positioning System;Optical fibers;Power capacitors;Uninterruptible power systems;&amp;#x03BB;-calculus with sums;Abstract machines;Continuation-passing style;Defunctionalization;Focalization;Intuitionistic logic;Polarization;Sequent calculus},
abstract = {The theory of the λ-calculus with extensional sums is more complex than with only pairs and functions. We propose an untyped representation-an intermediate calculus-for the λ-calculus with sums, based on the following principles: 1) Computation is described as the reduction of pairs of an expression and a context; the context must be represented inside-out, 2) operations are represented abstractly by their transition rule, 3) Positive and negative expressions are respectively eager and lazy; this polarity is an approximation of the type. We offer an introduction from the ground up to our approach, and we review the benefits. A structure of alternating phases naturally emerges through the study of normal forms, offering a reconstruction of focusing. Considering further purity assumption, we obtain maximal multifocusing. As an application, we can deduce a syntax-directed algorithm to decide the equivalence of normal forms in the simply-typed λ-calculus with sums, and justify it with our intermediate calculus.},
}

@inproceedings{MunchMaccagnoni2014FASIN,
author = {Munch-Maccagnoni, Guillaume},
title = {Formulae-as-Types for an Involutive Negation},
booktitle = {Proceedings of the Joint Meeting of the Twenty-Third {EACSL} Annual Conference on Computer Science Logic ({CSL}) and the Twenty-Ninth Annual {ACM}/{IEEE} Symposium on Logic in Computer Science ({LICS})},
series = {CSL-LICS~'14},
year = 2014,
isbn = {978-1-4503-2886-9},
location = {Vienna, Austria},
pages = {70:1--70:10},
articleno = 70,
numpages = 10,
@url = {http://doi.acm.org/10.1145/2603088.2603156},
doi = {10.1145/2603088.2603156},
acmid = 2603156,
publisher = {ACM},
address = {New York, NY, USA},
keywords = {classical logic, continuations, delimited control operators, focalization, formulae-as-types, polarization},
}

@article{Amal700,
 author = {Patterson, Daniel and Ahmed, Amal},
 title = {The Next 700 Compiler Correctness Theorems (Functional Pearl)},
 journal = {Proceedings of the {ACM} on Programming Languages},
 issue_date = {August 2019},
 volume = {3},
 number = {ICFP},
 @month = jul,
 year = {2019},
 issn = {2475-1421},
 pages = {85:1--85:29},
 articleno = {85},
 numpages = {29},
 @url = {http://doi.acm.org/10.1145/3341689},
 doi = {10.1145/3341689},
 acmid = {3341689},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {compilers, verification},
}

@article{Andreoli1992LPFPLL,
author = {Andreoli, Jean-Marc},
title = {Logic Programming with Focusing Proofs in Linear Logic},
journal = {Journal of Logic and Computation},
volume = 2,
number = 3,
pages = {297--347},
year = 1992,
doi = {10.1093/logcom/2.3.297},
@URL = {http://dx.doi.org/10.1093/logcom/2.3.297},
}

@phdThesis{Laurent2002PhD,
author = {Olivier Laurent},
title = {{\'E}tude de la polarisation en logique},
school = {Universit{\'e} de la M{\'e}diterran{\'e}e - Aix-Marseille II},
@type = {Th\`ese de Doctorat},
@month = mar,
year = 2002,
}

@inproceedings{OOScheme,
author = {Adams, Norman and Rees, Jonathan},
title = {Object-Oriented Programming in {Scheme}},
year = {1988},
isbn = {089791273X},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/62678.62720},
doi = {10.1145/62678.62720},
abstract = {We describe a small set of additions to Scheme to support object-oriented programming, including a form of multiple inheritance. The extensions proposed are in keeping with the spirit of the Scheme language and consequently differ from Lisp-based object systems such as Flavors and the Common Lisp Object System. Our extensions mesh neatly with the underlying Scheme system. We motivate our design with examples, and then describe implementation techniques that yields efficiency comparable to dynamic object-oriented language implementations considered to be high performance. The complete design has an almost-portable implementation, and the core of this design comprises the object system used in T, a dialect of Scheme. The applicative bias of our approach is unusual in object-oriented programming systems.},
booktitle = {Proceedings of the 1988 ACM Conference on LISP and Functional Programming},
pages = {277–288},
numpages = {12},
location = {Snowbird, Utah, USA},
series = {LFP~'88}
}

@book{OOLisp,
  title={Object-Oriented programming in {Common Lisp}; a programmer's guide to {CLOS}},
  author={Keene, Sonya E},
	edition={1},
  year={1989},
	isbn={0201175894},
	publisher={Addison-Wesley Professional},
}

@book{ArtOfMetaObjectProtocol,
  title={The art of the metaobject protocol},
  author={Kiczales, Gregor and Des Rivieres, Jim and Bobrow, Daniel G},
  year={1991},
  publisher={MIT press}
}

@book{UnderstandingCLOS,
author = {Lawless, Jo A. and Miller, Molly M.},
title = {Understanding {CLOS}: The {Common LISP} Object System},
year = {1991},
isbn = {1555580645},
publisher = {Digital Press},
address = {USA}
}

@manual{HaskellManual, 
  title={{Haskell} 2010 Language Report}, 
  author={Marlow, Simon}, 
  @url={http://www.haskell.org/}, 
  year={2010},
}

@manual{OCamlManual,
title = {The {OCaml} system},
author = {Xavier Leroy and Damien Doligez and Alain Frisch and Jacques Garrigue and Didier R{\'e}my and J{\'e}r{\^o}me Vouillon},
organization = {INRIA},
edition = {release 4.14},
year = 2022,
@month = mar,
}

@book{RustManual,
author = {Klabnik, Steve and Nichols, Carol},
title = {The Rust Programming Language},
year = {2018},
isbn = {1593278284},
publisher = {No Starch Press},
address = {USA},
abstract = {The Rust Programming Language is the official book on Rust, an open-source, community-developed systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety. This is the undisputed go-to guide to Rust, written by two members of the Rust core team, with feedback and contributions from 42 members of the community. The book assumes that youve written code in another programming language but makes no assumptions about which one, meaning the material is accessible and useful to developers from a wide variety of programming backgrounds. Known by the Rust community as The Book, The Rust Programming Language includes concept chapters, where youll learn about a particular aspect of Rust, and project chapters, where youll apply what youve learned so far to build small programs. The Book opens with a quick hands-on project to introduce the basics then explores key concepts in depth, such as ownership, the type system, error handling, and fearless concurrency. Next come detailed explanations of Rust-oriented perspectives on topics like pattern matching, iterators, and smart pointers, with concrete examples and exercises--taking you from theory to practice. The Rust Programming Language will also show you how to:- Grasp important concepts unique to Rust, like ownership, borrowing, and lifetimes- Use Cargo, Rusts built-in package manager, to build and maintain your code, including downloading and building dependencies- Effectively use Rusts zero-cost abstractions and employ your own Youll learn to develop reliable code thats speed and memory efficient, while avoiding the infamous and arcane programming pitfalls common at the systems level. When you need to dive down into lower-level control, this guide will show you how without taking on the customary risk of crashes or security holes and without requiring you to learn the fine points of a fickle toolchain. Youll also learn how to create command line programs, build single- and multithreaded web servers, and much more. The Rust Programming Language fully embraces Rusts potential to empower its users. This friendly and approachable guide will help you build not only your knowledge of Rust but also your ability to program with confidence in a wider variety of domains.}
}

@inproceedings{RustLang,
author = {Matsakis, Nicholas D. and Klock, Felix S.},
title = {The Rust Language},
year = {2014},
isbn = {9781450332170},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/2663171.2663188},
doi = {10.1145/2663171.2663188},
abstract = {Rust is a new programming language for developing reliable and efficient systems. It is designed to support concurrency and parallelism in building applications and libraries that take full advantage of modern hardware. Rust's static type system is safe1 and expressive and provides strong guarantees about isolation, concurrency, and memory safety.Rust also offers a clear performance model, making it easier to predict and reason about program efficiency. One important way it accomplishes this is by allowing fine-grained control over memory representations, with direct support for stack allocation and contiguous record storage. The language balances such controls with the absolute requirement for safety: Rust's type system and runtime guarantee the absence of data races, buffer overflows, stack overflows, and accesses to uninitialized or deallocated memory.},
booktitle = {Proceedings of the 2014 ACM SIGAda Annual Conference on High Integrity Language Technology},
pages = {103–104},
numpages = {2},
keywords = {affine type systems, rust, memory management, systems programming},
location = {Portland, Oregon, USA},
series = {HILT~'14}
}

@manual{ScalaManual,
title = {{Scala} 3 Reference},
edition = {3.1.3},
organization = {LAMP/EPFL},
year = {2022},
}

@book{JavaManual,
abstract = {Written by the inventors of the technology, this book, is the definitive technical reference for the Java programming language. If you want to know the precise meaning of the language's constructs, this is the source for you. The book provides complete, accurate, and detailed coverage of the Java programming language. It fully describes the new features added in Java SE 8, including lambda expressions, method references, default methods, type annotations, and repeating annotations.},
address = {Upper Saddle River, NJ},
author = {Gosling, James and Joy, Bill and Steele, Guy L. and Bracha, Gilad and Buckley, Alex},
edition = 5,
isbn = {978-0-13-390069-9},
publisher = {Addison-Wesley},
series = {Java Series},
title = {The Java Language Specification: Java SE 8 Edition},
@url = {http://docs.oracle.com/javase/specs/},
year = 2014
}


@book{ProgrammingRuby,
abstract = {The Pickaxe book, named for the tool on the cover, is the definitive reference to Ruby, a highly-regarded, fully object-oriented programming language. Ruby is the fastest growing and most exciting dynamic language out there. If you need to get working programs delivered fast, you should add Ruby to your toolbox. This book is the only complete reference for both Ruby 1.9 and Ruby 2.0, the very latest version of Ruby. 2013 marks the 20th anniversary of the Ruby language. Ruby is a fully object-oriented language, much like the classic object-oriented language, Smalltalk. Like Smalltalk, it is dynamically typed (as opposed to Java or C++), but unlike Smalltalk, Ruby features the same conveniences found in modern scripting languages such as Perl and Python. The combination of the power of a pure object-oriented language with the convenience of a scripting language makes Ruby a favorite tool of intelligent, forward-thinking programmers.},
address = {Dallas, TX},
author = {Thomas, David and Fowler, Chad and Hunt, Andrew},
edition = 4,
isbn = {978-1-93778-549-9},
keywords = {01841 103 book shelf software development script ruby},
publisher = {Pragmatic Bookshelf},
title = {Programming Ruby 1.9 \& 2.0: The Pragmatic Programmers' Guide},
year = 2013,
}

@inproceedings{TypeSoundnessDOT,
  author    = {Tiark Rompf and
               Nada Amin},
  @editor    = {Eelco Visser and
               Yannis Smaragdakis},
  title     = {Type soundness for dependent object types {(DOT)}},
  booktitle = {Proceedings of the 2016 {ACM} {SIGPLAN} International Conference on
               Object-Oriented Programming, Systems, Languages, and Applications,
               {OOPSLA} 2016, part of {SPLASH} 2016, Amsterdam, The Netherlands,
               October 30 - November 4, 2016},
  pages     = {624--641},
  publisher = {{ACM}},
  year      = {2016},
  @url       = {https://doi.org/10.1145/2983990.2984008},
  doi       = {10.1145/2983990.2984008},
}

@article{PathToDOT,
author = {Rapoport, Marianna and Lhot\'{a}k, Ond\v{r}ej},
title = {A Path to {DOT}: Formalizing Fully Path-Dependent Types},
year = 2019,
issue_date = {October 2019},
publisher = {ACM},
address = {New York, NY, USA},
volume = 3,
number = {OOPSLA},
@url = {https://doi.org/10.1145/3360571},
doi = {10.1145/3360571},
abstract = {The Dependent Object Types (DOT) calculus aims to formalize the Scala programming language with a focus on path-dependent types&nbsp;— types such as x.a1… an.T that depend on the runtime value of a path x.a1… an to an object. Unfortunately, existing formulations of DOT can model only types of the form x.A which depend on variables rather than general paths. This restriction makes it impossible to model nested module dependencies. Nesting small components inside larger ones is a necessary ingredient of a modular, scalable language. DOT’s variable restriction thus undermines its ability to fully formalize a variety of programming-language features including Scala’s module system, family polymorphism, and covariant specialization. This paper presents the pDOT calculus, which generalizes DOT to support types that depend on paths of arbitrary length, as well as singleton types to track path equality. We show that naive approaches to add paths to DOT make it inherently unsound, and present necessary conditions for such a calculus to be sound. We discuss the key changes necessary to adapt the techniques of the DOT soundness proofs so that they can be applied to pDOT. Our paper comes with a Coq-mechanized type-safety proof of pDOT. With support for paths of arbitrary length, pDOT can realize DOT’s full potential for formalizing Scala-like calculi.},
journal = {Proceedings of the ACM on Programming Languages},
@month = oct,
articleno = 145,
numpages = 29,
keywords = {paths, dependent types, Scala, DOT}
}

@manual{CoqManual,
  title = {The {Coq} Proof Assistant Reference Manual},
  organization = {INRIA, CNRS},
  edition = {version 8.16},
  year = 2021,
}

@manual{AgdaManual,
  title = {The {Agda} User Manual},
  organization = {The Agda Team},
  edition = {version 2.6.2.2},
  year = 2019,
}

@manual{IsabelleIsarManual,
title = {The {Isabelle/Isar} Reference Manual},
author = {Makarius Wenzel},
year = {2021},
@month = {Dec},
}

@manual{IsabelleManual,
title = {The {Isabelle} System Manual},
author = {Makarius Wenzel},
year = {2021},
@month = {Dec},
}

@article{FStarValueDependentTypes,
title={Secure distributed programming with value-dependent types},
volume={23},
DOI={10.1017/S0956796813000142},
number={4},
journal={Journal of Functional Programming},
publisher={Cambridge University Press},
author={Swamy, Nikhil and Chen, Juan and Fournet, C{\'e}dric and Strub, Pierre-Yves and Bhargavan, Karthikeyan and Yang, Jean},
year={2013},
pages={402–451}
}

@InProceedings{LeanSystemDescription,
author="de Moura, Leonardo
and Kong, Soonho
and Avigad, Jeremy
and van Doorn, Floris
and von Raumer, Jakob",
@editor="Felty, Amy P.
and Middeldorp, Aart",
title="The {Lean} Theorem Prover (System Description)",
booktitle="Automated Deduction - CADE-25",
year="2015",
publisher="Springer International Publishing",
address="Cham",
pages="378--388",
abstract="Lean is a new open source theorem prover being developed at Microsoft Research and Carnegie Mellon University, with a small trusted kernel based on dependent type theory. It aims to bridge the gap between interactive and automated theorem proving, by situating automated tools and methods in a framework that supports user interaction and the construction of fully specified axiomatic proofs. Lean is an ongoing and long-term effort, but it already provides many useful components, integrated development environments, and a rich API which can be used to embed it into other systems. It is currently being used to formalize category theory, homotopy type theory, and abstract algebra. We describe the project goals, system architecture, and main features, and we discuss applications and continuing work.",
isbn="978-3-319-21401-6"
}

@inproceedings{Lean4,
author = {Moura, Leonardo de and Ullrich, Sebastian},
title = {The {Lean} 4 Theorem Prover and Programming Language},
year = {2021},
isbn = {978-3-030-79875-8},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
@url = {https://doi.org/10.1007/978-3-030-79876-5_37},
doi = {10.1007/978-3-030-79876-5_37},
abstract = {Lean 4 is a reimplementation of the Lean interactive theorem prover (ITP) in Lean itself. It addresses many shortcomings of the previous versions and contains many new features. Lean 4 is fully extensible: users can modify and extend the parser, elaborator, tactics, decision procedures, pretty printer, and code generator. The new system has a hygienic macro system custom-built for ITPs. It contains a new typeclass resolution procedure based on tabled resolution, addressing significant performance problems reported by the growing user base. Lean 4 is also an efficient functional programming language based on a novel programming paradigm called functional but in-place. Efficient code generation is crucial for Lean users because many write custom proof automation procedures in Lean itself.},
booktitle = {Automated Deduction – CADE 28: 28th International Conference on Automated Deduction, Virtual Event, July 12–15, 2021, Proceedings},
pages = {625–635},
numpages = {11}
}

@book{bezem2003term,
  title={Term rewriting systems},
  author={Bezem, Marc and Klop, Jan Willem and de Vrijer, Roel},
  year={2003},
  publisher={Cambridge University Press, Cambridge Tracts in
                  Theoretical Computer Science}
}

@book{Sleep1993TGR,
 @editor = {Sleep, M. R. and Plasmeijer, M. J. and van Eekelen, M. C. J. D.},
 title = {Term Graph Rewriting: Theory and Practice},
 year = {1993},
 isbn = {0-471-93567-0},
 publisher = {John Wiley and Sons Ltd.},
 address = {Chichester, UK},
}

@article{Hagino1989CDML,
author = "Tatsuya Hagino",
title = "Codatatypes in {ML}",
journal = "Journal of Symbolic Computation",
volume = 8,
number = 6,
pages = "629 - 650",
year = 1989,
issn = "0747-7171",
doi = "https://doi.org/10.1016/S0747-7171(89)80065-3",
@url = "http://www.sciencedirect.com/science/article/pii/S0747717189800653",
abstract = "A new data type declaration mechanism of defining codatatypes is introduced to a functional programming language ML. Codatatypes are dual to datatypes for which ML already has a mechanism of defining. Sums and finite lists are defined as datatypes, but their duals, products and infinite lists, could not be defined in ML. This new facility gives ML the missing half of data types and makes ML symmetric. Categorical and domain-theoretic characterization of codatatypes are also given."
}

@inproceedings{BalzerPfenning2015OSTP,
 author = {Balzer, Stephanie and Pfenning, Frank},
 title = {Objects As Session-typed Processes},
 booktitle = {Proceedings of the 5th International Workshop on Programming Based on Actors, Agents, and Decentralized Control},
 series = {AGERE! 2015},
 year = {2015},
 isbn = {978-1-4503-3901-8},
 location = {Pittsburgh, PA, USA},
 pages = {13--24},
 numpages = {12},
 @url = {http://doi.acm.org/10.1145/2824815.2824817},
 doi = {10.1145/2824815.2824817},
 acmid = {2824817},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {linear types, object, process, protocol, session types},
}

@article{BalzerP17MSST,
  author    = {Stephanie Balzer and
               Frank Pfenning},
  title     = {Manifest sharing with session types},
  journal   = {{PACMPL}},
  volume    = {1},
  number    = {{ICFP}},
  pages     = {37:1--37:29},
  year      = {2017},
  @url       = {https://doi.org/10.1145/3110281},
  doi       = {10.1145/3110281},
}

@inproceedings{BalzerTP19MDFSST,
  author    = {Stephanie Balzer and
               Bernardo Toninho and
               Frank Pfenning},
  title     = {Manifest Deadlock-Freedom for Shared Session Types},
  booktitle = {Programming Languages and Systems - 28th European Symposium on Programming,
               {ESOP} 2019, Held as Part of the European Joint Conferences on Theory
               and Practice of Software, {ETAPS} 2019, Prague, Czech Republic, April
               6-11, 2019, Proceedings},
  pages     = {611--639},
  year      = {2019},
  @url       = {https://doi.org/10.1007/978-3-030-17184-1\_22},
  doi       = {10.1007/978-3-030-17184-1\_22},
}

@book{SangiorgiRutten2011ATBC,
 author = {Sangiorgi, Davide and Rutten, Jan},
 title = {Advanced Topics in Bisimulation and Coinduction},
 year = {2011},
 isbn = {1107004977, 9781107004979},
 edition = {1st},
 publisher = {Cambridge University Press},
 address = {New York, NY, USA},
}

@inproceedings{Rutten2019MCA,
  title={The Method of Coalgebra: Exercises in Coinduction},
  author={Jan J. M. M. Rutten},
  booktitle={FM 2019},
  year={2019}
}

@article{BoerRKP1991,
  author    = {Frank S. de Boer and
               Jan J. M. M. Rutten and
               Joost N. Kok and
               Catuscia Palamidessi},
  title     = {Semantic Models for Concurrent Logic Languages},
  journal   = {Theoretical Computer Science},
  volume    = {86},
  number    = {1},
  pages     = {3--33},
  year      = {1991},
  @url       = {https://doi.org/10.1016/0304-3975(91)90003-K},
  doi       = {10.1016/0304-3975(91)90003-K},
}

@inproceedings{Rutten1998,
  author    = {Jan J. M. M. Rutten},
  title     = {Automata and Coinduction (An Exercise in Coalgebra)},
  booktitle = {{CONCUR}~'98: Concurrency Theory, 9th International Conference, Nice,
               France, September 8-11, 1998, Proceedings},
  pages     = {194--218},
  year      = {1998},
  @url       = {https://doi.org/10.1007/BFb0055624},
  doi       = {10.1007/BFb0055624},
}

@article{ArbibManes1975,
author = "Michael A. Arbib and Ernest G. Manes",
title = "Adjoint machines, state-behavior machines, and duality",
journal = "Journal of Pure and Applied Algebra",
volume = 6,
number = 3,
pages = "313 - 344",
year = 1975,
issn = "0022-4049",
doi = "https://doi.org/10.1016/0022-4049(75)90028-6",
@url = "http://www.sciencedirect.com/science/article/pii/0022404975900286",
abstract = "A process X: KâK is output if Dyn(X)âK has a right adjoint; state-behavior if Dyn(X)âX has both left and right adjoints; and adjoint if X has a right adjoint and K has countable coproducts. Output processes provide the proper setting for a general theory of state observability. We give a minimal realization theory using image factorization of a total response map. We give an adjointness theory for state-behavior machines and a duality theory for adjoint machines which clarifies classical linear system duality and yields an improved duality for nondeterministic automata. Adjoint machines (machines with adjoint input processes) provide the first integration of classical sequential machines (the only state-behavior machines in the category, Set, of sets), metric machines, topological machines, linear systems, nondeterministic automata and Boolean machines. There exist state-behavior machines which are not adjoint (but not in Set)."
}

@article{ArbibManes1982,
author = "Michael A. Arbib and Ernest G. Manes",
title = "Parametrized data types do not need highly constrained parameters",
journal = "Information and Control",
volume = 52,
number = 2,
pages = "139 - 158",
year = 1982,
issn = "0019-9958",
doi = "https://doi.org/10.1016/S0019-9958(82)80026-0",
@url = "http://www.sciencedirect.com/science/article/pii/S0019995882800260",
abstract = "Data types may be considered as objects in any suitable category, and need not necessarily be ordered structures or many-sorted algebras. Arrays may be specified having as parameter any object from a category %plane1D;4A6; with finite products and coproducts, if products distribute over coproducts. The Lehmann-Smith least fixpoint approach to recursively-defined data types is extended by introducing the dual notion of greatest fixpoint, which allows the definition of infinite lists and trees without recourse to domains bearing a partial order structure. Finally, the least fixpoint approach is shown allowing the definition of queues directly in terms of stacks, rather than through a separate equational specification."
}

@book{ManesArbib1986,
  author    = {Ernest G. Manes and
               Michael A. Arbib},
  title     = {Algebraic Approaches to Program Ssemantics},
  series    = {Texts and Monographs in Computer Science},
  publisher = {Springer},
  year      = {1986},
  @url       = {https://doi.org/10.1007/978-1-4612-4962-7},
  doi       = {10.1007/978-1-4612-4962-7},
  isbn      = {978-0-387-96324-2},
}

@article{AczelBarwise1989NWFS,
  title={Non-well-founded sets},
  author={Aczel, Peter and Barwise, Jon},
  year={1989}
}

@book{Sangiorgi2011IBC,
 author = {Sangiorgi, Davide},
 title = {Introduction to Bisimulation and Coinduction},
 year = {2011},
 isbn = {1107003636, 9781107003637},
 publisher = {Cambridge University Press},
 address = {New York, NY, USA},
}

@book{Sangiorgi2001PC,
 author = {Sangiorgi, Davide and Walker, David},
 title = {The {$\pi$}-Calculus: A Theory of Mobile Processes},
 year = {2001},
 isbn = {0521781779},
 publisher = {Cambridge University Press},
 address = {New York, NY, USA},
}

@book{Milner1982CCS,
 author = {Milner, R.},
 title = {A  Calculus of Communicating Systems},
 year = {1982},
 isbn = {0387102353},
 publisher = {Springer-Verlag},
 address = {Berlin, Heidelberg},
}

@book{Milner1989CC,
  author    = {Robin Milner},
  title     = {Communication and concurrency},
  series    = {{PHI} Series in computer science},
  publisher = {Prentice Hall},
  year      = {1989},
  isbn      = {978-0-13-115007-2},
}

@inproceedings{Park1981CAIS,
  author    = {David Michael Ritchie Park},
  title     = {Concurrency and Automata on Infinite Sequences},
  booktitle = {Theoretical Computer Science, 5th GI-Conference, Karlsruhe, Germany,
               March 23-25, 1981, Proceedings},
  pages     = {167--183},
  year      = {1981},
  @url       = {https://doi.org/10.1007/BFb0017309},
  doi       = {10.1007/BFb0017309},
}

@article{Hoare1969ABCP,
 author = {Hoare, C. A. R.},
 title = {An Axiomatic Basis for Computer Programming},
 journal = {Communications of the ACM},
 issue_date = {Oct. 1969},
 volume = {12},
 number = {10},
 @month = oct,
 year = {1969},
 issn = {0001-0782},
 pages = {576--580},
 numpages = {5},
 @url = {http://doi.acm.org/10.1145/363235.363259},
 doi = {10.1145/363235.363259},
 acmid = {363259},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {axiomatic method, formal language definition, machine-independent programming, program documentation, programming language design, theory of programming' proofs of programs},
}

@article{Floyd1967Flowcharts,
  author = {Floyd, Robert W.},
  title = {Assigning Meanings to Programs},
  journal = {Proceedings of Symposium on Applied Mathematics},
  pages = {19--32},
  volume = 19,
  year = 1967,
  keywords = {Formal Languages},
  description = {A formal grammar for flowcharts.},
}

@article{McCarthy1959,
author = {John McCarthy},
title = {A Basis for a Mathematical Theory of Computation},
journal = {Studies in Logic and the Foundations of Mathematics},
year = 1959,
pages = {33--70},
}

@INPROCEEDINGS{McCarthyPainter67,
    author = {John Mccarthy and James Painter},
    title = {Correctness of a compiler for arithmetic expressions},
    booktitle = {},
    year = {1967},
    pages = {33--41},
    publisher = {American Mathematical Society}
}

@inproceedings{Morris1973ASC,
 author = {Morris, F. Lockwood},
 title = {Advice on Structuring Compilers and Proving Them Correct},
 booktitle = {Proceedings of the 1st Annual ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages},
 series = {POPL~'73},
 year = {1973},
 location = {Boston, Massachusetts},
 pages = {144--152},
 numpages = {9},
 @url = {http://doi.acm.org/10.1145/512927.512941},
 doi = {10.1145/512927.512941},
 acmid = {512941},
 publisher = {ACM},
 address = {New York, NY, USA},
} 

@article{Kennaway1995InfinitaryLC,
  title={Infinitary Lambda Calculus},
  author={Richard Kennaway and Jan Willem Klop and M. Ronan Sleep and Fer-Jan de Vries},
  journal={Theoretical Computer Science},
  year={1995},
  volume={175},
  pages={93-125}
}

@ARTICLE{Ariola96lambdacalculus,
    author = {Z. M. Ariola and J. W. Klop},
    title = {Lambda Calculus with Explicit Recursion},
    journal = {Information and Computation},
    year = {1996},
    volume = {139}
}

@article{
    Ken87,
    key = "Ken87",
    author = "Kennaway, J. R.",
    title = "On graph rewriting",
    journal = "Theoretical Computer Science",
    volume = "52",
    pages = "37-58",
    year = "1987",
}

@ARTICLE{Asp:Lan:94,
AUTHOR  = "Asperti, A. and Laneve, C.",
TITLE   = "Interaction Systems {I}:
        The theory of optimal reductions",
JOURNAL = "Mathematical structures for computer science",
YEAR    = 1994,
VOLUME  = 4,
PAGES   = "457--504"
}

@inProceedings{
    Lafont90,
    key = "Lafont90",
    author = "Lafont, Y.",
    title = "Interaction nets",
    booktitle = "Proc. ACM Conference on Principles of
    Programming Languages, San Francisco",
     year = 1990,
}

@inProceedings{
    KKSV93aa,
    key= "KKSV93aa",
    author = "Kennaway, J. R. and Klop, J. W. and Sleep, M. R. and
              de Vries, F. J.",
    title = "The adequacy of term graph rewriting for simulating
             term rewriting",
    booktitle = "Term Graph Rewriting: Theory and Practice",
    @editor ="M.  R. Sleep and M.  J. Plasmeijer and M.  C.  D.  J. van
                  Eekelen",
    publisher = "John Wiley \& Sons",
    pages = "157-168",
    year = "1993",
}


@article{Hughes1989WFPM,
 author = {Hughes, John},
 title = {Why Functional Programming Matters},
 journal = {The Computer Journal},
 issue_date = {April 1989},
 volume = {32},
 number = {2},
 @month = apr,
 year = {1989},
 issn = {0010-4620},
 pages = {98--107},
 numpages = {10},
 @url = {http://dx.doi.org/10.1093/comjnl/32.2.98},
 doi = {10.1093/comjnl/32.2.98},
 acmid = {63411},
 publisher = {Oxford University Press},
 address = {Oxford, UK},
}

@article{bohm85,
  author = {B\"ohm, Corrado and Berarducci, Alessandro},
  title = {Automatic Synthesis of Typed Lambda-Programs on Term Algebras},
  journal = {Theoretical Computer Science},
  volume = {39},
  pages = {135--154},
  year = {1985},
}

@book{GHJV1995DP,
 author = {Gamma, Erich and Helm, Richard and Johnson, Ralph and Vlissides, John},
 title = {Design Patterns: Elements of Reusable Object-oriented Software},
 year = {1995},
 isbn = {0-201-63361-2},
 publisher = {Addison-Wesley Longman Publishing Co., Inc.},
 address = {Boston, MA, USA},
}

@inproceedings{LaforgueR17,
author = {Laforgue, Paul and R\'{e}gis-Gianas, Yann},
title = {Copattern matching and first-class observations in {OCaml}, with a macro},
year = {2017},
isbn = {9781450352918},
publisher = {ACM},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3131851.3131869},
doi = {10.1145/3131851.3131869},
abstract = {Infinite data structures are elegantly defined by means of copattern matching, a dual construction to pattern matching that expresses the outcomes of the observations of an infinite structure. We extend the OCaml programming language with copatterns, exploiting the duality between pattern matching and copattern matching. Provided that a functional programming language has GADTs, every copattern matching can be transformed into a pattern matching via a purely local syntactic transformation, a macro. The development of this extension leads us to a generalization of previous calculus of copatterns: the introduction of first-class observation queries. We study this extension both from a formal and practical point of view.},
booktitle = {Proceedings of the 19th International Symposium on Principles and Practice of Declarative Programming},
pages = {97–108},
numpages = {12},
location = {Namur, Belgium},
series = {PPDP '17}
}

@article{DependentCopatterns,
author = {Cockx, Jesper and Abel, Andreas},
title = {Elaborating Dependent (Co)Pattern Matching},
year = 2018,
issue_date = {September 2018},
publisher = {ACM},
address = {New York, NY, USA},
volume = 2,
number = {ICFP},
@url = {https://doi.org/10.1145/3236770},
doi = {10.1145/3236770},
abstract = {In a dependently typed language, we can guarantee correctness of our programs by providing formal proofs. To check them, the typechecker elaborates these programs and proofs into a low level core language. However, this core language is by nature hard to understand by mere humans, so how can we know we proved the right thing? This question occurs in particular for dependent copattern matching, a powerful language construct for writing programs and proofs by dependent case analysis and mixed induction/coinduction. A definition by copattern matching consists of a list of clauses that are elaborated to a case tree, which can be further translated to primitive eliminators. In previous work this second step has received a lot of attention, but the first step has been mostly ignored so far. We present an algorithm elaborating definitions by dependent copattern matching to a core language with inductive datatypes, coinductive record types, an identity type, and constants defined by well-typed case trees. To ensure correctness, we prove that elaboration preserves the first-match semantics of the user clauses. Based on this theoretical work, we reimplement the algorithm used by Agda to check left-hand sides of definitions by pattern matching. The new implementation is at the same time more general and less complex, and fixes a number of bugs and usability issues with the old version. Thus we take another step towards the formally verified implementation of a practical dependently typed language.},
journal = {Proceedings of the {ACM} on Programming Languages},
@month = jul,
articleno = 75,
numpages = 30,
keywords = {Agda, Dependent types, Dependent pattern matching, Copatterns}
}

@article{Leroy2009FVCB,
 author = {Leroy, Xavier},
 title = {A Formally Verified Compiler Back-end},
 journal = {Journal of Automated Reasoning},
 issue_date = {December  2009},
 volume = {43},
 number = {4},
 @month = dec,
 year = {2009},
 issn = {0168-7433},
 pages = {363--446},
 numpages = {84},
 @url = {http://dx.doi.org/10.1007/s10817-009-9155-4},
 doi = {10.1007/s10817-009-9155-4},
 acmid = {1666216},
 publisher = {Springer-Verlag New York, Inc.},
 address = {Secaucus, NJ, USA},
 keywords = {Compiler transformations and optimizations, Compiler verification, Formal methods, Program proof, Semantic preservation, The Coq theorem prover},
}

@inproceedings{Leroy2006FCCB,
 author = {Leroy, Xavier},
 title = {Formal Certification of a Compiler Back-end or: Programming a Compiler with a Proof Assistant},
 booktitle = {Conference Record of the 33rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
 series = {POPL~'06},
 year = {2006},
 isbn = {1-59593-027-2},
 location = {Charleston, South Carolina, USA},
 pages = {42--54},
 numpages = {13},
 @url = {http://doi.acm.org/10.1145/1111037.1111042},
 doi = {10.1145/1111037.1111042},
 acmid = {1111042},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {certified compilation, compiler transformations and optimizations, program proof, semantic preservation, the Coq theorem prover},
}

@inproceedings{KangEtAl2016LVSC,
 author = {Kang, Jeehoon and Kim, Yoonseung and Hur, Chung-Kil and Dreyer, Derek and Vafeiadis, Viktor},
 title = {Lightweight Verification of Separate Compilation},
 booktitle = {Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
 series = {POPL~'16},
 year = {2016},
 isbn = {978-1-4503-3549-2},
 location = {St. Petersburg, FL, USA},
 pages = {178--190},
 numpages = {13},
 @url = {http://doi.acm.org/10.1145/2837614.2837642},
 doi = {10.1145/2837614.2837642},
 acmid = {2837642},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {CompCert, Compositional compiler verification, separate compilation},
}

@inproceedings{NeisEtAl2015Pils,
 author = {Neis, Georg and Hur, Chung-Kil and Kaiser, Jan-Oliver and McLaughlin, Craig and Dreyer, Derek and Vafeiadis, Viktor},
 title = {Pilsner: A Compositionally Verified Compiler for a Higher-order Imperative Language},
 booktitle = {Proceedings of the 20th ACM SIGPLAN International Conference on Functional Programming},
 series = {ICFP 2015},
 year = {2015},
 isbn = {978-1-4503-3669-7},
 location = {Vancouver, BC, Canada},
 pages = {166--178},
 numpages = {13},
 @url = {http://doi.acm.org/10.1145/2784731.2784764},
 doi = {10.1145/2784731.2784764},
 acmid = {2784764},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Compositional compiler verification, abstract types, higher-order state, parametric simulations, recursive types, transitivity},
}

@inproceedings{StewartEtAl2015CC,
 author = {Stewart, Gordon and Beringer, Lennart and Cuellar, Santiago and Appel, Andrew W.},
 title = {Compositional {CompCert}},
 booktitle = {Proceedings of the 42Nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
 series = {POPL~'15},
 year = {2015},
 isbn = {978-1-4503-3300-9},
 location = {Mumbai, India},
 pages = {275--287},
 numpages = {13},
 @url = {http://doi.acm.org/10.1145/2676726.2676985},
 doi = {10.1145/2676726.2676985},
 acmid = {2676985},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {compcert, compiler correctness},
}

@inproceedings{GuEtAl2015DSC,
 author = {Gu, Ronghui and Koenig, J{\'e}r{\'e}mie and Ramananandro, Tahina and Shao, Zhong and Wu, Xiongnan (Newman) and Weng, Shu-Chun and Zhang, Haozhong and Guo, Yu},
 title = {Deep Specifications and Certified Abstraction Layers},
 booktitle = {Proceedings of the 42Nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
 series = {POPL~'15},
 year = {2015},
 isbn = {978-1-4503-3300-9},
 location = {Mumbai, India},
 pages = {595--608},
 numpages = {14},
 @url = {http://doi.acm.org/10.1145/2676726.2676975},
 doi = {10.1145/2676726.2676975},
 acmid = {2676975},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {abstraction layer, certified compilers, certified os kernels, deep specification, modularity, program verification},
}

@article{WangEtAl2019ASBA,
 author = {Wang, Yuting and Wilke, Pierre and Shao, Zhong},
 title = {An Abstract Stack Based Approach to Verified Compositional Compilation to Machine Code},
 journal = {Proceedings of the {ACM} on Programming Languages},
 issue_date = {January 2019},
 volume = {3},
 number = {POPL},
 @month = jan,
 year = {2019},
 issn = {2475-1421},
 pages = {62:1--62:30},
 articleno = {62},
 numpages = {30},
 @url = {http://doi.acm.org/10.1145/3290375},
 doi = {10.1145/3290375},
 acmid = {3290375},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {abstract stack, certified compilers, compositional compilation, machine code generation, memory model},
}

@inproceedings{PercontiAhmed2014VOCMLS,
  author    = {James T. Perconti and
               Amal Ahmed},
  title     = {Verifying an Open Compiler Using Multi-language Semantics},
  booktitle = {Programming Languages and Systems - 23rd European Symposium on Programming,
               {ESOP} 2014, Held as Part of the European Joint Conferences on Theory
               and Practice of Software, {ETAPS} 2014, Grenoble, France, April 5-13,
               2014, Proceedings},
  pages     = {128--148},
  year      = {2014},
  @url       = {https://doi.org/10.1007/978-3-642-54833-8\_8},
  doi       = {10.1007/978-3-642-54833-8\_8},
}

@article{Denning1976LMSIF,
  author    = {Dorothy E. Denning},
  title     = {A Lattice Model of Secure Information Flow},
  journal   = {Communications of the {ACM}},
  volume    = 19,
  number    = 5,
  pages     = {236--243},
  year      = 1976,
  @url       = {https://doi.org/10.1145/360051.360056},
  doi       = {10.1145/360051.360056},
}

@article{DenningDenning1977CPSIF,
  author    = {Dorothy E. Denning and
               Peter J. Denning},
  title     = {Certification of Programs for Secure Information Flow},
  journal   = {Communications of the {ACM}},
  volume    = 20,
  number    = 7,
  pages     = {504--513},
  year      = 1977,
  @url       = {https://doi.org/10.1145/359636.359712},
  doi       = {10.1145/359636.359712},
}

@misc{Biba1977,
  author = {Biba, J. K.},
  title = {Integrity Considerations for Secure Computer Systems},
  year = 1977,
  isbn = {ESD-TR-76-372},
  publisher = {U.S. Air Force Electronic Systems Division},
  address = {Bedford, MA},
}

@article{ExpressionProblem,
  title={The expression problem},
  author={Wadler, Philip and others},
  journal={Posted on the Java Genericity mailing list},
  year={1998}
}

@InProceedings{IndependentlyExtensibleExpressionProblem,
  author =       {Martin Odersky and Matthias Zenger},
  title =        {Independently Extensible Solutions to the Expression Problem},
  booktitle =    {Proc. FOOL 12},
  year =         2005,
  @month =        jan,
  note =         {\verb@http://homepages.inf.ed.ac.uk/wadler/fool@}
}

@inproceedings{ShiversFisher04MultiReturn,
author = {Shivers, Olin and Fisher, David},
title = {Multi-Return Function Call},
year = {2004},
publisher = {ACM},
address = {New York, NY, USA},
booktitle = {Proceedings of the Ninth ACM SIGPLAN International Conference on Functional Programming},
pages = {79–89},
numpages = {11},
series = {ICFP~'04}
}

@article{LengrandMiquel2008CFOSC,
author = {St\'{e}phane Lengrand and Alexandre Miquel},
title = {Classical {$F_\omega$}, Orthogonality and Symmetric Candidates},
journal = {Annals of Pure and Applied Logic},
volume = 153,
number = 1,
pages = {3--20},
year = 2008,
issn = {0168-0072},
doi = {http://dx.doi.org/10.1016/j.apal.2008.01.005},
@url = {http://www.sciencedirect.com/science/article/pii/S0168007208000055},
keywords = {Classical logic, Classical version of system {$F_\omega$}},
abstract = {We present a version of system Fω, called Fωc, in which the layer of type constructors is essentially the traditional one of Fω, whereas provability of types is classical. The proof-term calculus accounting for the classical reasoning is a variant of Barbanera and Berardi’s symmetric λ-calculus. We prove that the whole calculus is strongly normalising. For the layer of type constructors, we use Tait and Girard’s reducibility method combined with orthogonality techniques. For the (classical) layer of terms, we use Barbanera and Berardi’s method based on a symmetric notion of reducibility candidate. We prove that orthogonality does not capture the fixpoint construction of symmetric candidates. We establish the consistency of Fωc, and relate the calculus to the traditional system Fω, also when the latter is extended with axioms for classical logic.},
}

@inproceedings{MelliesVouillon2005RPTPOF,
author = {Mellies, Paul-Andre and Vouillon, Jerome},
title = {Recursive Polymorphic Types and Parametricity in an Operational Framework},
booktitle = {Proceedings of the 20th Annual {IEEE} Symposium on Logic in Computer Science},
series = {LICS~'05},
year = {2005},
isbn = {0-7695-2266-1},
pages = {82--91},
numpages = {10},
@url = {http://dx.doi.org/10.1109/LICS.2005.42},
doi = {10.1109/LICS.2005.42},
acmid = {1079682},
publisher = {IEEE Computer Society},
address = {Washington, DC, USA},
} 

@article{RustBelt,
  title={{RustBelt}: Securing the foundations of the {Rust} programming language},
  author={Jung, Ralf and Jourdan, Jacques-Henri and Krebbers, Robbert and Dreyer, Derek},
  journal={Proceedings of the ACM on Programming Languages},
  volume={2},
  number={POPL},
  pages={1--34},
  year={2017},
  publisher={ACM New York, NY, USA}
}

@article{FearlessConcurrency,
  author    = {Zeming Yu and
               Linhai Song and
               Yiying Zhang},
  title     = {Fearless Concurrency? Understanding Concurrent Programming Safety
               in Real-World {Rust} Software},
  journal   = {CoRR},
  volume    = {abs/1902.01906},
  year      = {2019},
  @url       = {http://arxiv.org/abs/1902.01906},
  eprinttype = {arXiv},
  eprint    = {1902.01906},
}

@inproceedings{OwnershipTypes,
author = {Clarke, David G. and Potter, John M. and Noble, James},
title = {Ownership Types for Flexible Alias Protection},
year = {1998},
isbn = {1581130058},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/286936.286947},
doi = {10.1145/286936.286947},
abstract = {Object-oriented programming languages allow inter-object aliasing. Although necessary to construct linked data structures and networks of interacting objects, aliasing is problematic in that an aggregate object's state can change via an alias to one of its components, without the aggregate being aware of any aliasing. Ownership types form a static type system that indicates object ownership. This provides a flexible mechanism to limit the visibility of object references and restrict access paths to objects, thus controlling a system's dynamic topology. The type system is shown to be sound, and the specific aliasing properties that a system's object graph satisfies are formulated and proven invariant for well-typed programs.},
booktitle = {Proceedings of the 13th ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications},
pages = {48–64},
numpages = {17},
keywords = {alias protection, containment, ownership, programming language design, representation exposure, sharing},
location = {Vancouver, British Columbia, Canada},
series = {OOPSLA~'98}
}

@inproceedings{Cyclone,
  title={{Cyclone}: A safe dialect of {C}},
  author={Jim, Trevor and Morrisett, J Gregory and Grossman, Dan and Hicks, Michael W and Cheney, James and Wang, Yanling},
  booktitle={USENIX Annual Technical Conference, General Track},
  pages={275--288},
  year={2002}
}

@inproceedings{Vault,
author = {DeLine, Robert and F\"{a}hndrich, Manuel},
title = {Enforcing High-Level Protocols in Low-Level Software},
year = {2001},
isbn = {1581134142},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/378795.378811},
doi = {10.1145/378795.378811},
booktitle = {Proceedings of the ACM SIGPLAN 2001 Conference on Programming Language Design and Implementation},
pages = {59–69},
numpages = {11},
location = {Snowbird, Utah, USA},
series = {PLDI~'01}
}

@article{KindlyBentToFreeUs,
author = {Radanne, Gabriel and Saffrich, Hannes and Thiemann, Peter},
title = {Kindly Bent to Free Us},
year = {2020},
issue_date = {August 2020},
publisher = {ACM},
address = {New York, NY, USA},
volume = {4},
number = {ICFP},
@url = {https://doi.org/10.1145/3408985},
doi = {10.1145/3408985},
abstract = {Systems programming often requires the manipulation of resources like file handles, network connections, or dynamically allocated memory. Programmers need to follow certain protocols to handle these resources correctly. Violating these protocols causes bugs ranging from type mismatches over data races to use-after-free errors and memory leaks. These bugs often lead to security vulnerabilities. While statically typed programming languages guarantee type soundness and memory safety by design, most of them do not address issues arising from improper handling of resources. An important step towards handling resources is the adoption of linear and affine types that enforce single-threaded resource usage. However, the few languages supporting such types require heavy type annotations. We present Affe, an extension of ML that manages linearity and affinity properties using kinds and constrained types. In addition Affe supports the exclusive and shared borrowing of affine resources, inspired by features of Rust. Moreover, Affe retains the defining features of the ML family: it is an impure, strict, functional expression language with complete principal type inference and type abstraction. does not require any linearity annotations in expressions and supports common functional programming idioms.},
journal = {Proceedings of the {ACM} on Programming Languages},
@month = {aug},
articleno = {103},
numpages = {29},
keywords = {Linear types, Type inference, Functional programming, Ownership}
}

@article{ExpressivePower,
author = {Matthias Felleisen},
title = {On the Expressive Power of Programming Languages},
journal = {Science of Computer Programming},
volume = 17,
number = {1-3},
year = 1991,
pages = {35--75},
@url = {http://dx.doi.org/10.1016/0167-6423(91)90036-W},
doi = {10.1016/0167-6423(91)90036-W},
}

@inproceedings{milano2022flexible,
  title={A flexible type system for fearless concurrency},
  author={Milano, Mae and Turcotti, Joshua and Myers, Andrew C},
  booktitle={Proceedings of the 43rd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
  pages={458--473},
  year=2022
}

@inproceedings{RepresentingMonads,
author = {Filinski, Andrzej},
title = {Representing monads},
year = {1994},
isbn = {0897916360},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/174675.178047},
doi = {10.1145/174675.178047},
abstract = {We show that any monad whose unit and extension operations are expressible as purely functional terms can be embedded in a call-by-value language with “composable continuations”. As part of the development, we extend Meyer and Wand's characterization of the relationship between continuation-passing and direct style to one for continuation-passing vs. general “monadic” style. We further show that the composable-continuations construct can itself be represented using ordinary, non-composable first-class continuations and a single piece of state. Thus, in the presence of two specific computational effects - storage and escapes - any expressible monadic structure (e.g., nondeterminism as represented by the list monad) can be added as a purely definitional extension, without requiring a reinterpretation of the whole language. The paper includes an implementation of the construction (in Standard ML with some New Jersey extensions) and several examples.},
booktitle = {Proceedings of the 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {446–457},
numpages = {12},
location = {Portland, Oregon, USA},
series = {POPL~'94}
}

@inproceedings{RepresentingLayeredMonads,
author = {Filinski, Andrzej},
title = {Representing layered monads},
year = {1999},
isbn = {1581130953},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/292540.292557},
doi = {10.1145/292540.292557},
abstract = {There has already been considerable research on constructing modular, monad-based specifications of computational effects (state, exceptions, nondeterminism, etc.) in programming languages. We present a simple framework in this tradition, based on a Church-style effect-typing system for an ML-like language. The semantics of this language is formally defined by a series of monadic translations, each one expanding away a layer of effects. Such a layered specification is easy to reason about, but its direct implementation (whether by parameterized interpretation or by actual translation) is often prohibitively inefficient.By exploiting deeper semantic properties of monads, however, it is also possible to derive a vastly more efficient implementation: we show that each layer of effects can be uniformly simulated by continuation-passing, and further that multiple such layers can themselves be simulated by a standard semantics for call/cc and mutable state. Thus, even multi-effect programs can be executed in Scheme or SML/NJ at full native speed, generalizing an earlier single-effect result. As an example, we show how a simple resumption-based semantics of concurrency allows us to directly simulate a shared-state program across all possible dynamic interleavings of execution threads.},
booktitle = {Proceedings of the 26th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {175–188},
numpages = {14},
location = {San Antonio, Texas, USA},
series = {POPL~'99}
}

@techreport{FunctionalAbstractionTypedContexts,
    author = "Olivier Danvy and Andrzej Filinski",
    title = "A Functional Abstraction of Typed Contexts",
    institution = "DIKU, University of Copenhagen, Copenhagen, Denmark",
    number = "89/12",
    @months = " August",
    year = "1989"
}

@inproceedings{felleisen88,
author = {Felleisen, Mattias},
title = {The Theory and Practice of First-Class Prompts},
year = {1988},
isbn = {0897912527},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/73560.73576},
doi = {10.1145/73560.73576},
abstract = {An analysis of the λugr;-C-calculus and its problematic relationship to operational equivalence leads to a new control facility: the prompt-application. With the introduction of prompt-applications, the control calculus becomes a traditional calculus all of whose equations imply operational equivalence. In addition, prompt-applications enhance the expressiveness and efficiency of the language. We illustrate the latter claim with examples from such distinct areas as systems programming and tree processing.},
booktitle = {Proceedings of the 15th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {180–190},
numpages = {11},
location = {San Diego, California, USA},
series = {POPL~'88}
}

@article{AriolaBS2009SCAM,
  author       = {Zena M. Ariola and
                  Aaron Bohannon and
                  Amr Sabry},
  title        = {Sequent calculi and abstract machines},
  journal      = {{ACM} Transactions on Programming Languages and Systems},
  volume       = {31},
  number       = {4},
  pages        = {13:1--13:48},
  year         = {2009},
  @url          = {https://doi.org/10.1145/1516507.1516508},
  doi          = {10.1145/1516507.1516508},
}

@article{AriolaHS07,
  author       = {Zena M. Ariola and
                  Hugo Herbelin and
                  Amr Sabry},
  title        = {A proof-theoretic foundation of abortive continuations},
  journal      = {Higher-Order and Symbolic Computation},
  volume       = {20},
  number       = {4},
  pages        = {403--429},
  year         = {2007},
  @url          = {https://doi.org/10.1007/s10990-007-9007-z},
  doi          = {10.1007/S10990-007-9007-Z},
}

@article{AriolaHS09,
  author       = {Zena M. Ariola and
                  Hugo Herbelin and
                  Amr Sabry},
  title        = {A type-theoretic foundation of delimited continuations},
  journal      = {Higher-Order and Symbolic Computation},
  volume       = {22},
  number       = {3},
  pages        = {233--273},
  year         = {2009},
  @url          = {https://doi.org/10.1007/s10990-007-9006-0},
  doi          = {10.1007/S10990-007-9006-0},
}

@article{Sitaram:Felleisen:lasc:1990,
author = {Staram, Dorai and Felleisen, Matthias},
title = {Control Delimiters and Their Hierarchies},
year = {1990},
issue_date = {Jan. 1990},
publisher = {Kluwer Academic Publishers},
address = {USA},
volume = {3},
number = {1},
issn = {0892-4635},
@url = {https://doi.org/10.1007/BF01806126},
doi = {10.1007/BF01806126},
journal = {Lisp and Symbolic Computation},
@month = {may},
pages = {67–99},
numpages = {33}
}

@inproceedings{AbstractingControl,
  author       = {Olivier Danvy and
                  Andrzej Filinski},
  @editor       = {Gilles Kahn},
  title        = {Abstracting Control},
  booktitle    = {Proceedings of the 1990 {ACM} Conference on {LISP} and Functional
                  Programming, {LFP} 1990, Nice, France, 27-29 June 1990},
  pages        = {151--160},
  publisher    = {{ACM}},
	address = {New York, NY, USA},
  year         = {1990},
  @url          = {https://doi.org/10.1145/91556.91622},
  doi          = {10.1145/91556.91622},
}

@article{DoubleBarrelCPS,
author = {Thielecke, Hayo},
year = {2002},
@month = {09},
pages = {141-160},
title = {Comparing Control Constructs by Double-Barrelled {CPS}},
volume = {15},
journal = {Higher-Order and Symbolic Computation},
doi = {10.1023/A:1020887011500}
}

@inproceedings{HerbelinG08,
author = {Herbelin, Hugo and Ghilezan, Silvia},
title = {An Approach to Call-by-Name Delimited Continuations},
year = {2008},
isbn = {9781595936899},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/1328438.1328484},
doi = {10.1145/1328438.1328484},
abstract = {We show that a variant of Parigot's λμ-calculus, originally due to de Groote and proved to satisfy Boehm's theorem by Saurin, is canonically interpretable as a call-by-name calculus of delimited control. This observation is expressed using Ariola et al's call-by-value calculus of delimited control, an extension of λμ-calculus with delimited control known to be equationally equivalent to Danvy and Filinski's calculus with shift and reset. Our main result then is that de Groote and Saurin's variant of λμ-calculus is equivalent to a canonical call-by-name variant of Ariola et al's calculus. The rest of the paper is devoted to a comparative study of the call-by-name and call-by-value variants of Ariola et al's calculus, covering in particular the questions of simple typing, operational semantics, and continuation-passing-style semantics. Finally, we discuss the relevance of Ariola et al's calculus as a uniform framework for representing different calculi of delimited continuations, including "lazy" variants such as Sabry's shift and lazy reset calculus.},
booktitle = {Proceedings of the 35th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {383–394},
numpages = {12},
keywords = {boehm separability, classical logic, delimited control, observational completeness},
location = {San Francisco, California, USA},
series = {POPL~'08}
}

@inproceedings{materzok2011subtyping,
author = {Materzok, Marek and Biernacki, Dariusz},
title = {Subtyping Delimited Continuations},
year = {2011},
isbn = {9781450308656},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/2034773.2034786},
doi = {10.1145/2034773.2034786},
abstract = {We present a type system with subtyping for first-class delimited continuations that generalizes Danvy and Filinski's type system for shift and reset by maintaining explicit information about the types of contexts in the metacontext. We exploit this generalization by considering the control operators known as shift0 and reset0 that can access arbitrary contexts in the metacontext. We use subtyping to control the level of information about the metacontext the expression actually requires and in particular to coerce pure expressions into effectful ones. For this type system we prove strong type soundness and termination of evaluation and we present a provably correct type reconstruction algorithm. We also introduce two CPS translations for shift0 and reset0: one targeting the untyped lambda calculus, and another - type-directed - targeting the simply-typed lambda calculus. The latter translation preserves typability and is selective in that it keeps pure expressions in direct style.},
booktitle = {Proceedings of the 16th ACM SIGPLAN International Conference on Functional Programming},
pages = {81–93},
numpages = {13},
keywords = {continuation-passing style, type system, delimited continuation, subtyping},
location = {Tokyo, Japan},
series = {ICFP~'11}
}

@InProceedings{materzok2012dynamic,
author="Materzok, Marek
and Biernacki, Dariusz",
@editor="Jhala, Ranjit
and Igarashi, Atsushi",
title="A Dynamic Interpretation of the {CPS} Hierarchy",
booktitle="Programming Languages and Systems",
year="2012",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="296--311",
abstract="The CPS hierarchy of control operators shifti/resetiof Danvy and Filinski is a natural generalization of the shift and reset static control operators that allow for abstracting delimited control in a structured and CPS-guided manner. In this article we show that a dynamic variant of shift/reset, known as shift0/reset0, where the discipline of static access to the stack of delimited continuations is relaxed, can fully express the CPS hierarchy. This result demonstrates the expressive power of shift0/reset0 and it offers a new perspective on practical applications of the CPS hierarchy.",
isbn="978-3-642-35182-2",
doi={10.1007/978-3-642-35182-2\_21},
}

@article{KimYiDanvy98,
  title={Assessing the Overhead of {ML} Exceptions by Selective {CPS} Transformation},
  author={Jungtaek Kim and Kwangkeun Yi and Olivier Danvy},
  journal={BRICS Report Series},
  year={1998},
  volume={5},
}

@inproceedings{SelectiveCPS,
  author       = {Lasse R. Nielsen},
  @editor       = {Stephen D. Brookes and
                  Michael W. Mislove},
  title        = {A Selective {CPS} Transformation},
  booktitle    = {Seventeenth Conference on the Mathematical Foundations of Programming
                  Semantics, {MFPS} 2001, Aarhus, Denmark, May 23-26, 2001},
  series       = {Electronic Notes in Theoretical Computer Science},
  volume       = {45},
  pages        = {311--331},
  publisher    = {Elsevier},
  year         = {2001},
  @url          = {https://doi.org/10.1016/S1571-0661(04)80969-1},
  doi          = {10.1016/S1571-0661(04)80969-1},
}

@inproceedings{DeeperShallowEmbeddings,
  author       = {Jacob Prinz and
                  G. A. Kavvos and
                  Leonidas Lampropoulos},
  @editor       = {June Andronick and
                  Leonardo de Moura},
  title        = {Deeper Shallow Embeddings},
  booktitle    = {13th International Conference on Interactive Theorem Proving, {ITP}
                  2022, August 7-10, 2022, Haifa, Israel},
  series       = {LIPIcs},
  volume       = {237},
  pages        = {28:1--28:18},
  publisher    = {Schloss Dagstuhl - Leibniz-Zentrum f{\"{u}}r Informatik},
  year         = {2022},
  @url          = {https://doi.org/10.4230/LIPIcs.ITP.2022.28},
  doi          = {10.4230/LIPICS.ITP.2022.28},
}

@inproceedings{deep-vs-shallow-embedding,
  author       = {Richard J. Boulton and
                  Andrew D. Gordon and
                  Michael J. C. Gordon and
                  John Harrison and
                  John Herbert and
                  John Van Tassel},
  @editor       = {Victoria Stavridou and
                  Thomas F. Melham and
                  Raymond T. Boute},
  title        = {Experience with Embedding Hardware Description Languages in {HOL}},
  booktitle    = {Theorem Provers in Circuit Design, Proceedings of the {IFIP} {TC10/WG}
                  10.2 International Conference on Theorem Provers in Circuit Design:
                  Theory, Practice and Experience, Nijmegen, The Netherlands, 22-24
                  June 1992, Proceedings},
  series       = {{IFIP} Transactions},
  volume       = {{A-10}},
  pages        = {129--156},
  publisher    = {North-Holland},
  year         = {1992},
}

@article{FeatherweightJava,
author = {Igarashi, Atsushi and Pierce, Benjamin C. and Wadler, Philip},
title = {Featherweight Java: a minimal core calculus for Java and GJ},
year = {2001},
issue_date = {May 2001},
publisher = {ACM},
address = {New York, NY, USA},
volume = {23},
number = {3},
issn = {0164-0925},
@url = {https://doi.org/10.1145/503502.503505},
doi = {10.1145/503502.503505},
abstract = {Several recent studies have introduced lightweight versions of Java: reduced languages in which complex features like threads and reflection are dropped to enable rigorous arguments about key properties such as type safety. We carry this process a step further, omitting almost all features of the full language (including interfaces and even assignment) to obtain a small calculus, Featherweight Java, for which rigorous proofs are not only possible but easy. Featherweight Java bears a similar relation to Java as the lambda-calculus does to languages such as ML and Haskell. It offers a similar computational "feel," providing classes, methods, fields, inheritance, and dynamic typecasts with a semantics closely following Java's. A proof of type safety for Featherweight Java thus illustrates many of the interesting features of a safety proof for the full language, while remaining pleasingly compact. The minimal syntax, typing rules, and operational semantics of Featherweight Java make it a handy tool for studying the consequences of extensions and variations. As an illustration of its utility in this regard, we extend Featherweight Java with generic classes in the style of GJ (Bracha, Odersky, Stoutamire, and Wadler) and give a detailed proof of type safety. The extended system formalizes for the first time some of the key features of GJ.},
journal = {ACM Transactions on Programming Languages and Systems},
@month = {may},
pages = {396–450},
numpages = {55},
keywords = {Compilation, Java, generic classes, language design, language semantics}
}

@inproceedings{ProductLinesOfTheorems,
author = {Delaware, Benjamin and Cook, William and Batory, Don},
title = {Product lines of theorems},
year = {2011},
isbn = {9781450309400},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/2048066.2048113},
doi = {10.1145/2048066.2048113},
abstract = {Mechanized proof assistants are powerful verification tools, but proof development can be difficult and time-consuming. When verifying a family of related programs, the effort can be reduced by proof reuse. In this paper, we show how to engineer product lines with theorems and proofs built from feature modules. Each module contains proof fragments which are composed together to build a complete proof of correctness for each product. We consider a product line of programming languages, where each variant includes metatheory proofs verifying the correctness of its semantic definitions. This approach has been realized in the Coq proof assistant, with the proofs of each feature independently certifiable by Coq. These proofs are composed for each language variant, with Coq mechanically verifying that the composite proofs are correct. As validation, we formalize a core calculus for Java in Coq which can be extended with any combination of casts, interfaces, or generics.},
booktitle = {Proceedings of the 2011 ACM International Conference on Object Oriented Programming Systems Languages and Applications},
pages = {595–608},
numpages = {14},
keywords = {product line verification, mechanized metatheory, feature-orientation},
location = {Portland, Oregon, USA},
series = {OOPSLA~'11}
}

@inproceedings{EncodingFeatherweightJava,
author = {Mackay, Julian and Mehnert, Hannes and Potanin, Alex and Groves, Lindsay and Cameron, Nicholas},
title = {Encoding Featherweight Java with assignment and immutability using the Coq proof assistant},
year = {2012},
isbn = {9781450312721},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/2318202.2318206},
doi = {10.1145/2318202.2318206},
abstract = {We develop a mechanized proof of Featherweight Java with Assignment and Immutability in the Coq proof assistant. This is a step towards more machine-checked proofs of a non-trivial type system. We used object immutability close to that of IGJ [9]. We describe the challenges of the mechanisation and the encoding we used inside of Coq.},
booktitle = {Proceedings of the 14th Workshop on Formal Techniques for Java-like Programs},
pages = {11–19},
numpages = {9},
keywords = {Coq, automated theorem provers, immutability, type systems},
location = {Beijing, China},
series = {FTfJP~'12}
}

@inproceedings{InherentFeatherweightJava,
author = {Feitosa, Samuel da Silva and Mena, Alejandro Serrano and Ribeiro, Rodrigo Geraldo and Bois, Andre Rauber Du},
title = {An Inherently-Typed Formalization for Featherweight Java},
year = {2019},
isbn = {9781450376389},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/3355378.3355385},
doi = {10.1145/3355378.3355385},
abstract = {Featherweight Java is one of the most popular calculi which specify object-oriented programming features. It has been used as the basis for investigating novel language functionalities, as well as to specify and understand the formal properties of existing features for languages in this paradigm. However, when considering mechanized formalization, it is hard to find an implementation for languages with complex structures and binding mechanisms as Featherweight Java. In this paper we explore an inherently-typed approach to formalize Featherweight Java, implementing the static and dynamic semantics in Agda using dependent types, and then replicating it in Coq (the latter using the Equations plug-in). Using this approach, the interpreter is correct by construction, since the type checker of the host language is responsible for verifying type safety, thus avoiding repetitions of proofs and error checking.},
booktitle = {Proceedings of the XXIII Brazilian Symposium on Programming Languages},
pages = {11–18},
numpages = {8},
keywords = {Mechanized Semantics, Featherweight Java, Dependent Types, Agda},
location = {Salvador, Brazil},
series = {SBLP~'19}
}

@article{ExtrinsicFeatherweightJava,
  author       = {Samuel da Silva Feitosa and
                  Rodrigo Geraldo Ribeiro and
                  Andr{\'{e}} Rauber Du Bois},
  title        = {Towards an Extrinsic Formalization of Featherweight Java in Agda},
  journal      = {{CLEI} Electronic Journal},
  volume       = {24},
  number       = {3},
  year         = {2021},
  @url          = {https://doi.org/10.19153/cleiej.24.3.3},
  doi          = {10.19153/CLEIEJ.24.3.3},
}


@book            {Pierce:SFold,
author       =   {Benjamin C. Pierce and Arthur {Azevedo de Amorim}
                  and Chris Casinghino and Marco Gaboardi and
                  Michael Greenberg and C\v{a}t\v{a}lin Hri\c{t}cu
                  and Vilhelm Sj\"{o}berg and Brent Yorgey},
title        =   "Software Foundations",
year         =   2017,
publisher    =   "Electronic textbook",
plclub       =   yes,
bcp          =   yes,
keys         =   "verification,books",
note         =   {Version 5.0.  \@url{http://www.cis.upenn.edu/~bcpierce/sf}},
ebook        =   {http://www.cis.upenn.edu/~bcpierce/sf},
japanese     =   {http://proofcafe.org/sf}
}

@book            {Pierce:SF1,
author       =   {Benjamin C. Pierce and Arthur {Azevedo de Amorim}
                  and Chris Casinghino and Marco Gaboardi and
                  Michael Greenberg and C\v{a}t\v{a}lin Hri\c{t}cu
                  and Vilhelm Sj\"{o}berg and Brent Yorgey},
title        =   "Logical Foundations",
series       =  "Software Foundations series, volume 1",
@month        =   jan,
year         =   "2024",
publisher    =   "Electronic textbook",
plclub       =   yes,
bcp          =   yes,
keys         =   "verification,books",
note         =   {Version 6.6.  \@url{http://www.cis.upenn.edu/~bcpierce/sf}},
ebook        =   {http://www.cis.upenn.edu/~bcpierce/sf},
japanese     =   {http://proofcafe.org/sf}
}


@book            {Pierce:SF1-old,
author       =   {Benjamin C. Pierce and Arthur {Azevedo de Amorim}
                  and Chris Casinghino and Marco Gaboardi and
                  Michael Greenberg and C\v{a}t\v{a}lin Hri\c{t}cu
                  and Vilhelm Sj\"{o}berg and Brent Yorgey},
title        =   "Logical Foundations",
series       =  "Software Foundations series, volume 1",
@month        =   May,
year         =   "2018",
publisher    =   "Electronic textbook",
plclub       =   yes,
bcp          =   yes,
keys         =   "verification,books",
note         =   {Version 5.5.  \@url{http://www.cis.upenn.edu/~bcpierce/sf}},
ebook        =   {http://www.cis.upenn.edu/~bcpierce/sf},
japanese     =   {http://proofcafe.org/sf}
}

@book            {Pierce:SF2,
author       =   {Benjamin C. Pierce and Arthur {Azevedo de Amorim}
                  and Chris Casinghino and Marco Gaboardi and
                  Michael Greenberg and C\v{a}t\v{a}lin Hri\c{t}cu
                  and Vilhelm Sj\"{o}berg and Andrew Tolmach
                  and Brent Yorgey},
title        =   "Programming Language Foundations",
series       =  "Software Foundations series, volume 2",
@month        =   jan,
year         =   "2024",
publisher    =   "Electronic textbook",
plclub       =   yes,
bcp          =   yes,
keys         =   "verification,books",
note         =   {Version 6.6.  \@url{http://www.cis.upenn.edu/~bcpierce/sf}},
ebook        =   {http://www.cis.upenn.edu/~bcpierce/sf},
}

@book            {Pierce:SF2-old,
author       =   {Benjamin C. Pierce and Arthur {Azevedo de Amorim}
                  and Chris Casinghino and Marco Gaboardi and
                  Michael Greenberg and C\v{a}t\v{a}lin Hri\c{t}cu
                  and Vilhelm Sj\"{o}berg and Andrew Tolmach
                  and Brent Yorgey},
title        =   "Programming Language Foundations",
series       =  "Software Foundations series, volume 2",
@month        =   May,
year         =   "2018",
publisher    =   "Electronic textbook",
plclub       =   yes,
bcp          =   yes,
keys         =   "verification,books",
note         =   {Version 5.5.  \@url{http://www.cis.upenn.edu/~bcpierce/sf}},
ebook        =   {http://www.cis.upenn.edu/~bcpierce/sf},
japanese     =   {http://proofcafe.org/sf}
}

@book            {Appel:SF4,
author       =   {Andrew W. Appel},
title        =   "Verified Functional Algorithms",
series       =  "Software Foundations series, volume 3",
@month        =   aug,
year         =   2023,
publisher    =   "Electronic textbook",
plclub       =   yes,
bcp          =   yes,
keys         =   "verification,books",
note         =   {\@url{http://www.cis.upenn.edu/~bcpierce/sf}},
ebook        =   {http://www.cis.upenn.edu/~bcpierce/sf},
}

@book            {Pierce:SF4,
author       =   {Leonidas Lampropoulos and Benjamin C. Pierce},
title        =   "{QuickChick}: Property-Based Testing in {Coq}",
series       =  "Software Foundations series, volume 4",
@month        =   aug,
year         =   "2023",
publisher    =   "Electronic textbook",
plclub       =   yes,
bcp          =   yes,
keys         =   "verification,books",
note         =   {\@url{http://www.cis.upenn.edu/~bcpierce/sf}},
ebook        =   {http://www.cis.upenn.edu/~bcpierce/sf},
}

@book            {Pierce:SF4-old,
author       =   {Leonidas Lampropoulos and Benjamin C. Pierce},
title        =   "{QuickChick}: Property-Based Testing in {Coq}",
series       =  "Software Foundations series, volume 4",
@month        =   Aug,
year         =   "2018",
publisher    =   "Electronic textbook",
plclub       =   yes,
bcp          =   yes,
keys         =   "verification,books",
note         =   {\@url{http://www.cis.upenn.edu/~bcpierce/sf}},
ebook        =   {http://www.cis.upenn.edu/~bcpierce/sf},
}

@misc{sexytypes,
  author = {Satnam Singh and
            Simon Peyton Jones and
            Ulf Norell and
            Fran\c{c}ois Pottier and
            Erik Meijer and
            Conor McBride},
  title  = {Sexy Types---Are We Done Yet?},
  howpublished = {Software Summit},
  @month  = apr,
  year   = 2011,
  @url    = {https://research.microsoft.com/apps/video/dl.aspx?id=150045},
	@quote = {We are obsessed with foundations partly because we are aware of a number of significant foundational problems that we’ve got to get right before we can do anything realistic. The thing I would think of in particular in that respect is coinduction and reasoning about corecursive processes. That’s currently, in all major implementations of type theory, a disaster. And if we’re going to talk about real systems, we’ve got to actually have something sensible to say about that.},
}


@InProceedings{CoCGuardedRecursion,
author="Gim{\'e}nez, Eduarde",
@editor="Dybjer, Peter
and Nordstr{\"o}m, Bengt
and Smith, Jan",
title="Codifying guarded definitions with recursive schemes",
booktitle="Types for Proofs and Programs",
year="1995",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="39--59",
abstract="We formalize an extension of the Calculus of Constructions with inductive and coinductive types which allows a more direct description of recursive definitions. The approach we follow is close to the one proposed for Martin-L{\"o}f's type theory in [5]. Recursive objects can be defined by fixed-point definitions as in functional programming languages, and a syntactical checking of these definitions avoids the introduction of non-normalizable terms. We show that the conditions for accepting a recursive definition proposed in [5] are not sufficient for the Calculus of Constructions, and we modify them. As a way of justifying our conditions, we develop a general method to codify a fix point definition satisfying them using well-known recursive schemes, like primitive recursion and co-recursion. We also propose different reduction rules from the ones used in [5] in order to obtain a decidable conversion relation for the system.",
isbn="978-3-540-47770-9"
}

@unpublished{CoinductionInCoq,
  TITLE = {CoInduction in {Coq}},
  AUTHOR = {Bertot, Yves},
  @URL = {https://cel.hal.science/inria-00001174},
  NOTE = {Lecture},
  TYPE = {DEA},
  ADDRESS = {EU's coordination action Types Goteborg},
  YEAR = {2005},
  KEYWORDS = {Calculus of inductive constructions ; Coq ; Co-induction},
  PDF = {https://cel.hal.science/inria-00001174/file/co.pdf},
  HAL_ID = {inria-00001174},
  HAL_VERSION = {v1},
}

@inproceedings{CorecursiveFunctionsInCoq,
  author       = {Yves Bertot and
                  Ekaterina Komendantskaya},
  @editor       = {Jir{\'{\i}} Ad{\'{a}}mek and
                  Clemens Kupke},
  title        = {Inductive and Coinductive Components of Corecursive Functions in {C}oq},
  booktitle    = {Proceedings of the Ninth Workshop on Coalgebraic Methods in Computer
                  Science, {CMCS} 2008, Budapest, Hungary, April 4-6, 2008},
  series       = {Electronic Notes in Theoretical Computer Science},
  volume       = {203},
  number       = {5},
  pages        = {25--47},
  publisher    = {Elsevier},
  year         = {2008},
  @url          = {https://doi.org/10.1016/j.entcs.2008.05.018},
  doi          = {10.1016/J.ENTCS.2008.05.018},
}

@inproceedings{DegenerateSigma,
  author       = {Hugo Herbelin},
  @editor       = {Pawel Urzyczyn},
  title        = {On the Degeneracy of Sigma-Types in Presence of Computational Classical
                  Logic},
  booktitle    = {Typed Lambda Calculi and Applications, 7th International Conference,
                  {TLCA} 2005, Nara, Japan, April 21-23, 2005, Proceedings},
  @series       = {Lecture Notes in Computer Science},
  volume       = {3461},
  pages        = {209--220},
  publisher    = {Springer},
  year         = {2005},
  @url          = {https://doi.org/10.1007/11417170\_16},
  doi          = {10.1007/11417170\_16},
}

@article{FireTriangle,
author = {P\'{e}drot, Pierre-Marie and Tabareau, Nicolas},
title = {The fire triangle: how to mix substitution, dependent elimination, and effects},
year = 2019,
issue_date = {January 2020},
publisher = {ACM},
address = {New York, NY, USA},
volume = 4,
number = {POPL},
@url = {https://doi.org/10.1145/3371126},
doi = {10.1145/3371126},
abstract = {There is a critical tension between substitution, dependent elimination and effects in type theory. In this paper, we crystallize this tension in the form of a no-go theorem that constitutes the fire triangle of type theory. To release this tension, we propose ∂CBPV, an extension of call-by-push-value (CBPV) —a general calculus of effects—to dependent types. Then, by extending to ∂CBPV the well-known decompositions of call-by-name and call-by-value into CBPV, we show why, in presence of effects, dependent elimination must be restricted in call-by-name, and substitution must be restricted in call-by-value. To justify ∂CBPV and show that it is general enough to interpret many kinds of effects, we define various effectful syntactic translations from ∂CBPV to Martin-L\"{o}f type theory: the reader, weaning and forcing translations.},
journal = {Proceedings of the ACM on Programming Languages},
@month = dec,
articleno = 58,
numpages = 28,
keywords = {type theory, effects}
}

@inproceedings{SemanticValueRestriction,
author = {Lepigre, Rodolphe},
title = {A Classical Realizability Model for a Semantical Value Restriction},
year = {2016},
isbn = {9783662494974},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
@url = {https://doi.org/10.1007/978-3-662-49498-1_19},
doi = {10.1007/978-3-662-49498-1_19},
abstract = {We present a new type system with support for proofs of programs in a call-by-value language with control operators. The proof mechanism relies on observational equivalence of untyped programs. It appears in two type constructors, which are used for specifying program properties and for encoding dependent products.The main challenge arises from the lack of expressiveness of dependent products due to the value restriction. To circumvent this limitation we relax the syntactic restriction and only require equivalence to a value.The consistency of the system is obtained semantically by constructing a classical realizability model in three layers values, stacks and terms.},
booktitle = {Proceedings of the 25th European Symposium on Programming Languages and Systems - Volume 9632},
pages = {476–502},
numpages = {27}
}

@inproceedings{pedrot:hal-01441829,
  TITLE = {{An Effectful Way to Eliminate Addiction to Dependence}},
  AUTHOR = {P{\'e}drot, Pierre-Marie and Tabareau, Nicolas},
  @URL = {https://inria.hal.science/hal-01441829},
  BOOKTITLE = {{Logic in Computer Science (LICS), 2017 32nd Annual ACM/IEEE Symposium on}},
  ADDRESS = {Reykjavik, Iceland},
  HAL_LOCAL_REFERENCE = {ACTI+},
  PAGES = {12},
  YEAR = {2017},
  @MONTH = Jun,
  DOI = {10.1109/LICS.2017.8005113},
  PDF = {https://inria.hal.science/hal-01441829/file/main.pdf},
  HAL_ID = {hal-01441829},
  HAL_VERSION = {v1},
}

@phdthesis{MiqueyPhD,
  author       = {{\'{E}}tienne Miquey},
  title        = {Classical realizability and side-effects. (R{\'{e}}alisabilit{\'{e}}
                  classique et effets de bords)},
  school       = {University of the Republic, Montevideo, Uruguay},
  year         = {2017},
  @url          = {https://tel.archives-ouvertes.fr/tel-01653733},
}


@inproceedings{Miquey2017,
  author       = {{\'{E}}tienne Miquey},
  @editor       = {Hongseok Yang},
  title        = {A Classical Sequent Calculus with Dependent Types},
  booktitle    = {Programming Languages and Systems - 26th European Symposium on Programming,
                  {ESOP} 2017, Held as Part of the European Joint Conferences on Theory
                  and Practice of Software, {ETAPS} 2017, Uppsala, Sweden, April 22-29,
                  2017, Proceedings},
  @series       = {Lecture Notes in Computer Science},
  volume       = {10201},
  pages        = {777--803},
  publisher    = {Springer},
  year         = {2017},
  @url          = {https://doi.org/10.1007/978-3-662-54434-1\_29},
  doi          = {10.1007/978-3-662-54434-1\_29},
}

@article{Miquey2019,
  author       = {{\'{E}}tienne Miquey},
  title        = {A Classical Sequent Calculus with Dependent Types},
  journal      = {{ACM} Transactions on Programming Languages and Systems},
  volume       = {41},
  number       = {2},
  pages        = {8:1--8:47},
  year         = {2019},
  @url          = {https://doi.org/10.1145/3230625},
  doi          = {10.1145/3230625},
}

@article{GuillermoMiquey2018,
  author       = {Mauricio Guillermo and
                  {\'{E}}tienne Miquey},
  title        = {Classical realizability and arithmetical formul{\ae}},
  journal      = {Mathematical Structures in Computer Science},
  volume       = {27},
  number       = {6},
  pages        = {1068--1107},
  year         = {2017},
  @url          = {https://doi.org/10.1017/S0960129515000559},
  doi          = {10.1017/S0960129515000559},
}

@inproceedings{Miquey2018,
  author       = {{\'{E}}tienne Miquey},
  @editor       = {Anuj Dawar and
                  Erich Gr{\"{a}}del},
  title        = {A sequent calculus with dependent types for classical arithmetic},
  booktitle    = {Proceedings of the 33rd Annual {ACM/IEEE} Symposium on Logic in Computer
                  Science, {LICS} 2018, Oxford, UK, July 09-12, 2018},
  pages        = {720--729},
  publisher    = {{ACM}},
  year         = {2018},
  @url          = {https://doi.org/10.1145/3209108.3209199},
  doi          = {10.1145/3209108.3209199},
}

@inproceedings{MiqueyHerbelin2018,
  author       = {{\'{E}}tienne Miquey and
                  Hugo Herbelin},
  @editor       = {Christel Baier and
                  Ugo Dal Lago},
  title        = {Realizability Interpretation and Normalization of Typed Call-by-Need
                  {\textbackslash}lambda -calculus with Control},
  booktitle    = {Foundations of Software Science and Computation Structures - 21st
                  International Conference, {FOSSACS} 2018, Held as Part of the European
                  Joint Conferences on Theory and Practice of Software, {ETAPS} 2018,
                  Thessaloniki, Greece, April 14-20, 2018, Proceedings},
  @series       = {Lecture Notes in Computer Science},
  volume       = {10803},
  pages        = {276--292},
  publisher    = {Springer},
  year         = {2018},
  @url          = {https://doi.org/10.1007/978-3-319-89366-2\_15},
  doi          = {10.1007/978-3-319-89366-2\_15},
}

@inproceedings{CohenMiqueyTate2021,
  author       = {Liron Cohen and
                  {\'{E}}tienne Miquey and
                  Ross Tate},
  title        = {Evidenced Frames: {A} Unifying Framework Broadening Realizability
                  Models},
  booktitle    = {36th Annual {ACM/IEEE} Symposium on Logic in Computer Science, {LICS}
                  2021, Rome, Italy, June 29 - July 2, 2021},
  pages        = {1--13},
  publisher    = {{IEEE}},
  year         = {2021},
  @url          = {https://doi.org/10.1109/LICS52264.2021.9470514},
  doi          = {10.1109/LICS52264.2021.9470514},
}

@inproceedings{BCGM2023,
  author       = {Emmanuel Beffara and
                  F{\'{e}}lix Castro and
                  Mauricio Guillermo and
                  {\'{E}}tienne Miquey},
  @editor       = {Marco Gaboardi and
                  Femke van Raamsdonk},
  title        = {Concurrent Realizability on Conjunctive Structures},
  booktitle    = {8th International Conference on Formal Structures for Computation
                  and Deduction, {FSCD} 2023, July 3-6, 2023, Rome, Italy},
  series       = {LIPIcs},
  volume       = {260},
  pages        = {28:1--28:21},
  publisher    = {Schloss Dagstuhl - Leibniz-Zentrum f{\"{u}}r Informatik},
  year         = {2023},
  @url          = {https://doi.org/10.4230/LIPIcs.FSCD.2023.28},
  doi          = {10.4230/LIPICS.FSCD.2023.28},
}

@article{DinisMiquey2023,
  author       = {Bruno Dinis and
                  {\'{E}}tienne Miquey},
  title        = {Stateful Realizers for Nonstandard Analysis},
  journal      = {Logical Methods in Computer Science},
  volume       = {19},
  number       = {2},
  year         = {2023},
  @url          = {https://doi.org/10.46298/lmcs-19(2:7)2023},
  doi          = {10.46298/LMCS-19(2:7)2023},
}

@InProceedings{GAcoDTs,
author="Ostermann, Klaus
and Jabs, Julian",
@editor="Ahmed, Amal",
title="Dualizing Generalized Algebraic Data Types by Matrix Transposition",
booktitle="Programming Languages and Systems",
year="2018",
publisher="Springer International Publishing",
address="Cham",
pages="60--85",
abstract="We characterize the relation between generalized algebraic datatypes (GADTs) with pattern matching on their constructors one hand, and generalized algebraic co-datatypes (GAcoDTs) with copattern matching on their destructors on the other hand: GADTs can be converted mechanically to GAcoDTs by refunctionalization, GAcoDTs can be converted mechanically to GADTs by defunctionalization, and both defunctionalization and refunctionalization correspond to a transposition of the matrix in which the equations for each constructor/destructor pair of the (co-)datatype are organized. We have defined a calculus, {\$}{\$}GADT^T{\$}{\$}GADTT, which unifies GADTs and GAcoDTs in such a way that GADTs and GAcoDTs are merely different ways to partition the program.",
isbn="978-3-319-89884-1"
}


@article{10.1145/640128.604144,
author = {Thielecke, Hayo},
title = {From control effects to typed continuation passing},
year = {2003},
isbn = {1581136285},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/604131.604144},
doi = {10.1145/604131.604144},
abstract = {First-class continuations are a powerful computational effect, allowing the programmer to express any form of jumping. Types and effect systems can be used to reason about continuations, both in the source language and in the target language of the continuation-passing transform. In this paper, we establish the connection between an effect system for first-class continuations and typed versions of continuation-passing style. A region in the effect system determines a local answer type for continuations, such that the continuation transforms of pure expressions are parametrically polymorphic in their answer types. We use this polymorphism to derive transforms that make use of effect information, in particular, a mixed linear/non-linear continuation-passing transform, in which expressions without control effects are passed their continuations linearly.},
booktitle = {Proceedings of the 30th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {139–149},
numpages = {11},
keywords = {continuations, control effects, polymorphism, type and effect systems},
location = {New Orleans, Louisiana, USA},
series = {POPL~'03}
}


@inproceedings{AnswerTypePolyNaturality,
author = {Thielecke, Hayo},
title = {From control effects to typed continuation passing},
year = {2003},
isbn = {1581136285},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/604131.604144},
doi = {10.1145/604131.604144},
abstract = {First-class continuations are a powerful computational effect, allowing the programmer to express any form of jumping. Types and effect systems can be used to reason about continuations, both in the source language and in the target language of the continuation-passing transform. In this paper, we establish the connection between an effect system for first-class continuations and typed versions of continuation-passing style. A region in the effect system determines a local answer type for continuations, such that the continuation transforms of pure expressions are parametrically polymorphic in their answer types. We use this polymorphism to derive transforms that make use of effect information, in particular, a mixed linear/non-linear continuation-passing transform, in which expressions without control effects are passed their continuations linearly.},
booktitle = {Proceedings of the 30th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {139–149},
numpages = {11},
keywords = {continuations, control effects, polymorphism, type and effect systems},
location = {New Orleans, Louisiana, USA},
series = {POPL~'03}
}

@InProceedings{AnswerTypePolyEta,
author="Thielecke, Hayo",
@editor="Schmidt, David",
title="Answer Type Polymorphism in Call-by-Name Continuation Passing",
booktitle="Programming Languages and Systems",
year=2004,
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="279--293",
doi={10.1007/978-3-540-24725-8_20},
abstract="This paper studies continuations by means of a polymorphic type system. The traditional call-by-name continuation passing style transform admits a typing in which some answer types are polymorphic, even in the presence of first-class control operators. By building on this polymorphic typing, and using parametricity reasoning, we show that the call-by-name transform satisfies the eta-law, and is in fact isomorphic to the more recent CPS transform defined by Streicher.",
isbn="978-3-540-24725-8"
}

@inproceedings{ContinuationModels,
author = {Hofmann, Martin and Streicher, Thomas},
title = {Continuation models are universal for lambda-mu-calculus},
year = {1997},
isbn = {0818679255},
publisher = {IEEE Computer Society},
address = {USA},
abstract = {We show that a certain simple call-by-name continuation semantics of Parigot's lambda-mu-calculus is complete. More precisely, for every lambda-mu-theory we construct a cartesian closed category such that the ensuing continuation-style interpretation of lambda-mu, which maps terms to functions sending abstract continuations to responses, is full and faithful. Thus, any lambda-mu-category in the sense of is isomorphic to a continuation model derived from a cartesian-closed category of continuations.},
booktitle = {Proceedings of the 12th Annual IEEE Symposium on Logic in Computer Science},
pages = {387},
series = {LICS '97},
doi = {10.1109/LICS.1997.614964},
}

@article{ClassicalLogicContinuationSemantics,
author = {Streicher, Th. and Reus, B.},
title = {Classical logic, continuation semantics and abstract machines},
year = {1998},
issue_date = {November 1998},
publisher = {Cambridge University Press},
address = {USA},
volume = {8},
number = {6},
issn = {0956-7968},
url = {https://doi.org/10.1017/S0956796898003141},
doi = {10.1017/S0956796898003141},
abstract = {One of the goals of this paper is to demonstrate that denotational semantics is useful for operational issues like implementation of functional languages by abstract machines. This is exemplified in a tutorial way by studying the case of extensional untyped call-by-name λ-calculus with Felleisen's control operator 𝒞. We derive the transition rules for an abstract machine from a continuation semantics which appears as a generalization of the ¬¬-translation known from logic. The resulting abstract machine appears as an extension of Krivine's machine implementing head reduction. Though the result, namely Krivine's machine, is well known our method of deriving it from continuation semantics is new and applicable to other languages (as e.g. call-by-value variants). Further new results are that Scott's D∞-models are all instances of continuation models. Moreover, we extend our continuation semantics to Parigot's λμ-calculus from which we derive an extension of Krivine's machine for λμ-calculus. The relation between continuation semantics and the abstract machines is made precise by proving computational adequacy results employing an elegant method introduced by Pitts.},
journal = {Journal of Functional Programming},
month = nov,
pages = {543–572},
numpages = {30}
}

@inproceedings{CBNSyntacticCPS,
author = {Fujita, Ken-Etsu},
title = {A sound and complete {CPS}-translation for {$\lambda\mu$}-calculus},
year = {2003},
isbn = {3540403329},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {We investigate injectivity of the novel CPS-translation with surjective pairing which is originally introduced by Hofmann-Streicher. It is syntactically proved that the CPS-translation is sound and complete not only for the λ-calculus but also for the extensional λµ-calculus. The injective CPS-translation reveals a Church-Rosser fragment of the λ-calculus with surjective pairing and a neat connection to C-monoids.},
booktitle = {Proceedings of the 6th International Conference on Typed Lambda Calculi and Applications},
pages = {120–134},
numpages = {15},
location = {Valencia, Spain},
series = {TLCA'03},
doi = {10.1007/3-540-44904-3_9},
}

@InProceedings{PolymorphicDelimCont,
author="Asai, Kenichi
and Kameyama, Yukiyoshi",
@editor="Shao, Zhong",
title="Polymorphic Delimited Continuations",
booktitle="Programming Languages and Systems",
year="2007",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="239--254",
abstract="This paper presents a polymorphic type system for a language with delimited control operators, shift and reset. Based on the monomorphic type system by Danvy and Filinski, the proposed type system allows pure expressions to be polymorphic. Thanks to the explicit presence of answer types, our type system satisfies various important properties, including strong type soundness, existence of principal types and an inference algorithm, and strong normalization. Relationship to CPS translation as well as extensions to impredicative polymorphism are also discussed. These technical results establish the foundation of polymorphic delimited continuations.",
isbn="978-3-540-76637-7",
@url={https://doi.org/10.1007/978-3-540-76637-7_16},
}

@mastersthesis{EpicAgda,
author = {Olle Fredrickson and Daniel Gustaffson},
title = {A totally {Epic} backend for {Agda}},
school = {Chalmers University of Technology, University of Gothenburg},
@month = may,
year = 2011,
}

@mastersthesis{CorbynMasters,
author = {Nathan Corbyn},
title = {Proof Synthesis with Free Extensions in Intensional Type Theory},
school = {King's College, University of Cambridge},
@month = jun,
year = 2021,
}

@InProceedings{GCS2014PCTLC,
author="Gross, Jason
and Chlipala, Adam
and Spivak, David I.",
@editor="Klein, Gerwin
and Gamboa, Ruben",
title="Experience Implementing a Performant Category-Theory Library in {Coq}",
booktitle="Interactive Theorem Proving",
year="2014",
publisher="Springer International Publishing",
address="Cham",
pages="275--291",
abstract="We describe our experience implementing a broad category-theory library in Coq. Category theory and computational performance are not usually mentioned in the same breath, but we have needed substantial engineering effort to teach Coq to cope with large categorical constructions without slowing proof script processing unacceptably. In this paper, we share the lessons we have learned about how to represent very abstract mathematical objects and arguments in Coq and how future proof assistants might be designed to better support such reasoning. One particular encoding trick to which we draw attention allows category-theoretic arguments involving duality to be internalized in Coq's logic with definitional equality. Ours may be the largest Coq development to date that uses the relatively new Coq version developed by homotopy type theorists, and we reflect on which new features were especially helpful.",
isbn="978-3-319-08970-6"
}

@inproceedings{LJD2020TT,
author = {L\'{o}pez Juan, V\'{\i}ctor and Danielsson, Nils Anders},
title = {Practical dependent type checking using twin types},
year = {2020},
isbn = {9781450380515},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/3406089.3409030},
doi = {10.1145/3406089.3409030},
abstract = {People writing proofs or programs in dependently typed languages can omit some function arguments in order to decrease the code size and improve readability. Type checking such a program involves filling in each of these implicit arguments in a type-correct way. This is typically done using some form of unification. One approach to unification, taken by Agda, involves sometimes starting to unify terms before their types are known to be equal: in some cases one can make progress on unifying the terms, and then use information gleaned in this way to unify the types. This flexibility allows Agda to solve implicit arguments that are not found by several other systems. However, Agda's implementation is buggy: sometimes the solutions chosen are ill-typed, which can cause the type checker to crash. With Gundry and McBride's twin variable technique one can also start to unify terms before their types are known to be equal, and furthermore this technique is accompanied by correctness proofs. However, so far this technique has not been tested in practice as part of a full type checker. We have reformulated Gundry and McBride's technique without twin variables, using only twin types, with the aim of making the technique easier to implement in existing type checkers (in particular Agda). We have also introduced a type-agnostic syntactic equality rule that seems to be useful in practice. The reformulated technique has been tested in a type checker for a tiny variant of Agda. This type checker handles at least one example that Coq, Idris, Lean and Matita cannot handle, and does so in time and space comparable to that used by Agda. This suggests that the reformulated technique is usable in practice.},
booktitle = {Proceedings of the 5th ACM SIGPLAN International Workshop on Type-Driven Development},
pages = {11–23},
numpages = {13},
keywords = {dependent types, type checking, unification},
location = {Virtual Event, USA},
series = {TyDe 2020}
}

@techreport{Chlipala2004,
  author = {Adam Chlipala},
  title = {An Untrusted Verifier for Typed Assembly Language},
  institution = {UC Berkeley EECS Department},
  type = {Technical report},
  number = {UCB/ERL M04/41},
  year = {2004},
}

@InProceedings{CCN2006,
author="Chang, Bor-Yuh Evan
and Chlipala, Adam
and Necula, George C.",
@editor="Emerson, E. Allen
and Namjoshi, Kedar S.",
title="A Framework for Certified Program Analysis and Its Applications to Mobile-Code Safety",
booktitle="Verification, Model Checking, and Abstract Interpretation",
year="2006",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="174--189",
abstract="A certified program analysis is an analysis whose implementation is accompanied by a checkable proof of soundness. We present a framework whose purpose is to simplify the development of certified program analyses without compromising the run-time efficiency of the analyses. At the core of the framework is a novel technique for automatically extracting Coq proof-assistant specifications from ML implementations of program analyses, while preserving to a large extent the structure of the implementation. We show that this framework allows developers of mobile code to provide to the code receivers untrusted code verifiers in the form of certified program analyses. We demonstrate efficient implementations in this framework of bytecode verification, typed assembly language, and proof-carrying code.",
isbn="978-3-540-31622-0",
@url={https://doi.org/10.1007/11609773_12},
}

@inproceedings{CCKWICKZ2017,
author = {Chen, Haogang and Chajed, Tej and Konradi, Alex and Wang, Stephanie
                  and Ileri, Atalay and Chlipala, Adam and Kaashoek,
                  M. Frans and Zeldovich, Nickolai},
title = {Verifying a high-performance crash-safe file system using a tree specification},
year = {2017},
isbn = {9781450350853},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/3132747.3132776},
doi = {10.1145/3132747.3132776},
abstract = {DFSCQ is the first file system that (1) provides a precise specification for fsync and fdatasync, which allow applications to achieve high performance and crash safety, and (2) provides a machine-checked proof that its implementation meets this specification. DFSCQ's specification captures the behavior of sophisticated optimizations, including log-bypass writes, and DFSCQ's proof rules out some of the common bugs in file-system implementations despite the complex optimizations.The key challenge in building DFSCQ is to write a specification for the file system and its internal implementation without exposing internal file-system details. DFSCQ introduces a metadata-prefix specification that captures the properties of fsync and fdatasync, which roughly follows the behavior of Linux ext4. This specification uses a notion of tree sequences---logical sequences of file-system tree states---for succinct description of the possible states after a crash and to describe how data writes can be reordered with respect to metadata updates. This helps application developers prove the crash safety of their own applications, avoiding application-level bugs such as forgetting to invoke fsync on both the file and the containing directory.An evaluation shows that DFSCQ achieves 103 MB/s on large file writes to an SSD and durably creates small files at a rate of 1,618 files per second. This is slower than Linux ext4 (which achieves 295 MB/s for large file writes and 4,977 files/s for small file creation) but much faster than two recent verified file systems, Yggdrasil and FSCQ. Evaluation results from application-level benchmarks, including TPC-C on SQLite, mirror these microbenchmarks.},
booktitle = {Proceedings of the 26th Symposium on Operating Systems Principles},
pages = {270–286},
numpages = {17},
location = {Shanghai, China},
series = {SOSP~'17}
}

@inproceedings{PPJEC2022,
author = {Pit-Claudel, Cl\'{e}ment and Philipoom, Jade and Jamner, Dustin and Erbsen, Andres and Chlipala, Adam},
title = {Relational compilation for performance-critical applications: extensible proof-producing translation of functional models into low-level code},
year = {2022},
isbn = {9781450392655},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/3519939.3523706},
doi = {10.1145/3519939.3523706},
abstract = {There are typically two ways to compile and run a purely functional program verified using an interactive theorem prover (ITP): automatically extracting it to a similar language (typically an unverified process, like Coq to OCaml) or manually proving it equivalent to a lower-level reimplementation (like a C program). Traditionally, only the latter produced both excellent performance and end-to-end proofs.

This paper shows how to recast program extraction as a proof-search problem to automatically derive correct-by-construction, high-performance code from purely functional programs.
We call this idea relational compilation — it extends recent developments with novel solutions to loop-invariant inference and genericity in kinds of side effects.

Crucially, relational compilers are incomplete, and unlike traditional compilers, they generate good code not because of a fixed set of clever built-in optimizations but because they allow experts to plug in domain--specific extensions that give them complete control over the compiler's output.

We demonstrate the benefits of this approach with Rupicola, a new compiler-construction toolkit designed to extract fast, verified, idiomatic low-level code from annotated functional models. Using case studies and performance benchmarks, we show that it is extensible with minimal effort and that it achieves performance on par with that of handwritten C programs.},
booktitle = {Proceedings of the 43rd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
pages = {918–933},
numpages = {16},
keywords = {verification, theorem proving, compilation},
location = {San Diego, CA, USA},
series = {PLDI 2022}
}

@inproceedings{CakeML,
author = {Kumar, Ramana and Myreen, Magnus O. and Norrish, Michael and Owens, Scott},
title = {CakeML: a verified implementation of ML},
year = {2014},
isbn = {9781450325448},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/2535838.2535841},
doi = {10.1145/2535838.2535841},
abstract = {We have developed and mechanically verified an ML system called CakeML, which supports a substantial subset of Standard ML. CakeML is implemented as an interactive read-eval-print loop (REPL) in x86-64 machine code. Our correctness theorem ensures that this REPL implementation prints only those results permitted by the semantics of CakeML. Our verification effort touches on a breadth of topics including lexing, parsing, type checking, incremental and dynamic compilation, garbage collection, arbitrary-precision arithmetic, and compiler bootstrapping.Our contributions are twofold. The first is simply in building a system that is end-to-end verified, demonstrating that each piece of such a verification effort can in practice be composed with the others, and ensuring that none of the pieces rely on any over-simplifying assumptions. The second is developing novel approaches to some of the more challenging aspects of the verification. In particular, our formally verified compiler can bootstrap itself: we apply the verified compiler to itself to produce a verified machine-code implementation of the compiler. Additionally, our compiler proof handles diverging input programs with a lightweight approach based on logical timeout exceptions. The entire development was carried out in the HOL4 theorem prover.},
booktitle = {Proceedings of the 41st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {179–191},
numpages = {13},
keywords = {verified type checking, verified parsing, verified garbage collection., read-eval-print loop, machine code verification, compiler verification, compiler bootstrapping, ML},
location = {San Diego, California, USA},
series = {POPL~'14}
}

@inproceedings{BDMT2019,
  author = {Heiko Becker and
            Eva Darulova and
            Magnus O. Myreen and
            Zachary Tatlock},
  title = {Icing: Supporting Fast-math Style Optimizations in a Verified Compiler},
  year = 2019,
  booktitle = {Computer Aided Verification ({CAV})},
  publisher = {Springer},
  @url = {https://cakeml.org/cav19.pdf}
}

@inproceedings{BRDMTKTF2022,
  author = {Heiko Becker and
            Robert Rabe and
            Eva Darulova and
            Magnus O. Myreen and
            Zachary Tatlock and
            Ramana Kumar and
            Yong Kiam Tan and
            Anthony Fox},
  title = {Verified Compilation and Optimization of Floating-Point Programs in {CakeML}},
  year = 2022,
  booktitle = {European Conference on Object-Oriented Programming ({ECOOP})},
  publisher = {LIPIcs},
  @url = {https://drops.dagstuhl.de/opus/volltexte/2022/16229/pdf/LIPIcs-ECOOP-2022-1.pdf}
}

@article{BTMO2024GrokkingSC,
  author    = {David Binder and Marco Tzschentke and Marius Müller and Klaus Ostermann},
  title     = {Grokking the Sequent Calculus (Functional Pearl)},
  journal   = {Proceedings of the {ACM} on Programming Languages},
  volume    = {8},
  number    = {{ICFP}},
  year      = {2024},
}

@book{CompilingWithContinuations,
author = {Appel, Andrew W.},
title = {Compiling with Continuations},
year = {2007},
isbn = {052103311X},
publisher = {Cambridge University Press},
address = {USA},
abstract = {This book shows how continuation-passing style is used as an intermediate representation to perform optimizations and program transformations. Continuations can be used to compile most programming languages. The method is illustrated in a compiler for the programming language Standard ML. Prior knowledge of ML, however, is not necessary, as the author carefully explains each concept as it arises. This is the first book to show how concepts from the theory of programming languages can be applied to the production of practical optimizing compilers for modern languages like ML. All the details of compiling are covered, including the interface to a runtime system and garbage collector.}
}

@article{BCRA2018CPSSigma,
  author       = {William J. Bowman and
                  Youyou Cong and
                  Nick Rioux and
                  Amal Ahmed},
  title        = {Type-preserving {CPS} translation of {\(\Sigma\)} and {\(\Pi\)} types
                  is not not possible},
  journal      = {Proceedings of the {ACM} on Programming Languages},
  volume       = {2},
  number       = {{POPL}},
  pages        = {22:1--22:33},
  year         = {2018},
  @url          = {https://doi.org/10.1145/3158110},
  doi          = {10.1145/3158110},
}

@article{WorkerWrapper,
title={The worker/wrapper transformation},
volume={19},
DOI={10.1017/S0956796809007175},
number={2},
journal={Journal of Functional Programming},
author={Gill, Andy and Hutton, Graham},
year={2009},
pages={227--251}
}


@book{deBakker1980,
author = {Bakker, J. W. de},
title = {Mathematical Theory of Program Correctness},
year = {1980},
isbn = {0135621321},
publisher = {Prentice-Hall, Inc.},
address = {USA}
}

@book{Bird98,
author = {Bird, Richard},
title = {Introduction to Functional Programming Using {Haskell} (second edition)},
year = {1998},
publisher = {Prentice-Hall, Inc.}
}

@book{Bird88,
author = {Bird, Richard and Wadler, Philip},
title = {An Introduction to Functional Programming}, 
year = {1988},
publisher = {Prentice-Hall, Inc.}
}

@article{Sangiorgi2009,
author = {Sangiorgi, Davide},
title = {On the Origins of Bisimulation and Coinduction},
year = {2009},
issue_date = {May 2009},
publisher = {ACM},
address = {New York, NY, USA},
volume = {31},
number = {4},
issn = {0164-0925},
@url = {https://doi.org/10.1145/1516507.1516510},
doi = {10.1145/1516507.1516510},
abstract = {The origins of bisimulation and bisimilarity are examined, in the three fields where they have been independently discovered: Computer Science, Philosophical Logic (precisely, Modal Logic), Set Theory.Bisimulation and bisimilarity are coinductive notions, and as such are intimately related to fixed points, in particular greatest fixed points. Therefore also the appearance of coinduction and fixed points is discussed, though in this case only within Computer Science. The paper ends with some historical remarks on the main fixed-point theorems (such as Knaster-Tarski) that underpin the fixed-point theory presented.},
journal = {ACM Transactions on Programming Languages and Systems},
@month = {may},
articleno = {15},
numpages = {41},
keywords = {greatest fixed points, fixed points, coinduction, Bisimulation, history}
}

@article{Grapham_Gibbons01,
author = {Hutton, Graham and Gibbons, Jeremy},
year = {2001},
@month = {08},
pages = {197-201},
title = {The Generic Approximation Lemma},
volume = {79},
journal = {Information Processing Letters},
abstract = {The approximation lemma is a simplification of the well-known take lemma, and is used to prove properties of programs that produce lists of values. We show how the approximation lemma, unlike the take lemma, can naturally be generalized from lists to a large class of datatypes, and present a generic approximation lemma that is parametric in the datatype to which it applies. As a useful by-product, we find that generalizing the approximation lemma in this way also simplifies its proof.},
doi = {10.1016/S0020-0190(00)00220-9}
}

@article{kozen_silva_2017,
title={Practical coinduction},
volume={27},
DOI={10.1017/S0960129515000493},
number={7},
journal={Mathematical Structures in Computer Science},
publisher={Cambridge University Press},
author={Kozen, Dexter and Silva, Alexandra},
year={2017},
pages={1132–1152}
}

@book{RuttenMethodofCoalgebra,
title={The Method of Coalgebra: Exercises in coinduction},
author={Rutten, Jan},
year={2019},
@month=feb,
numpages={261},
publisher={CWI, Amsterdam, The Netherlands},
isbn={978-90-6196-568-8},
}

@inproceedings{RoyOPLSSCoinduction,
author = {Crole Roy},
title = {Coinduction and bisimilarity},
booktitle = {Oregon Programming Languages Summer School},
series = {OPLSS},
year = {2003},
}

@misc{GordonWhatIsCoinduction,
author = {Mike Gordon},
title = {Corecursion and coinduction: what they are and how they relate to recursion and induction},
year = {2017},
@url = {https://www.cl.cam.ac.uk/archive/mjcg/Blog/WhatToDo/Coinduction.pdf},
}

@InProceedings{GordonTutorialOnCoinduction,
author = {Gordon, Andy},
title = {A Tutorial on Co-induction and Functional Programming},
booktitle = {Proceedings of the 1994 Glasgow Workshop on Functional Programming, Ayr, Scotland},
year = {1994},
@month = {September},
abstract = {Co-induction is an important tool for reasoning about unbounded structures. This tutorial explains the foundations of co-induction, and shows how it justifies intuitive arguments about lazy streams, of central importance to lazy functional programmers. We explain from first principles a theory based on a new formulation of bisimilarity for functional programs, which coincides exactly with Morris-style contextual equivalence. We show how to prove properties of lazy streams by co-induction and derive Bird and Wadler's Take Lemma, a well-known proof technique for lazy streams.},
publisher = {Springer London},
@url = {https://www.microsoft.com/en-us/research/publication/a-tutorial-on-co-induction-and-functional-programming/},
pages = {78-95},
isbn = {978-3-540-19914-4 (Print) 978-1-4471-3573-9 (Online)},
edition = {Proceedings of the 1994 Glasgow Workshop on Functional Programming, Ayr, Scotland}
}

@article{ProofMethodsCorecursive,
author = {Gibbons, Jeremy and Hutton, Graham},
year = {2005},
@month = {04},
pages = {353-366},
title = {Proof Methods for Corecursive Programs},
volume = {66},
journal = {Fundamenta Informaticae}
}

@inproceedings{Unfold99,
    author = {Jeremy Gibbons and Geraint Jones},
    title = {The Under-Appreciated Unfold},
    booktitle = {In Proceedings of the Third ACM SIGPLAN International Conference on Functional Programming},
    year = {1998},
    pages = {273--279},
    publisher = {ACM Press},
}

@inproceedings{Graham99,
author = {Hutton, Graham},
title = {Fold and Unfold for Program Semantics},
year = {1998},
isbn = {1581130244},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/289423.289457},
doi = {10.1145/289423.289457},
abstract = {In this paper we explain how recursion operators can be used to structure and reason about program semantics within a functional language. In particular, we show how the recursion operator fold can be used to structure denotational semantics, how the dual recursion operator unfold can be used to structure operational semantics, and how algebraic properties of these operators can be used to reason about program semantics. The techniques are explained with the aid of two main examples, the first concerning arithmetic expressions, and the second concerning Milner's concurrent language CCS. The aim of the paper is to give functional programmers new insights into recursion operators, program semantics, and the relationships between them.},
booktitle = {Proceedings of the Third ACM SIGPLAN International Conference on Functional Programming},
pages = {280–288},
numpages = {9},
location = {Baltimore, Maryland, USA},
series = {ICFP~'98}
}

@INPROCEEDINGS{GeuversIterationRecursion,
author = {Herman Geuvers},
title = {Inductive and Coinductive types with Iteration and Recursion},
booktitle = {Proceedings of the 1992 Workshop on Types for Proofs and Programs, Bastad},
year = {1992},
pages = {193--217}
}

@inproceedings{CPSCoinductiveTypes,
author = {Barthe, Gilles and Uustalu, Tarmo},
title = {{CPS} Translating Inductive and Coinductive Types},
booktitle = {Proceedings of the 2002 ACM SIGPLAN Workshop on Partial Evaluation and Semantics-Based Program Manipulation},
series = {PEPM ’02},
year = {2002},
isbn = {158113455X},
@url = {https://doi.org/10.1145/503032.503043},
doi = {10.1145/503032.503043},
pages = {131–142},
numpages = {12},
location = {Portland, Oregon},
publisher = {ACM},
address = {New York, NY, USA},
keywords = {CPS translations, dependent types, classical logic and control, typed λ-calculi, inductive and coinductive types},
}

@inproceedings{StackCalculus,
author = {Alberto Carraro and Thomas Ehrhard and Antonino Salibra},
title = {The Stack Calculus},
booktitle = {Proceedings Seventh Workshop on Logical and Semantic Frameworks, with Applications},
series = {{LSFA} 2012},
location = {Rio de Janeiro, Brazil},
@month = sep,
year = {2012},
pages = {93--108},
@url = {http://dx.doi.org/10.4204/EPTCS.113.10},
doi = {10.4204/EPTCS.113.10},
}

@inproceedings{LambdaMuCons,
Author = {Koji Nakazawa and Tomoharu Nagai},
Title = {Reduction System for Extensional Lambda-mu Calculus.},
Booktitle = {Rewriting and Typed Lambda Calculi},
Ee = {http://dx.doi.org/10.1007/978-3-319-08918-8_24},
Pages = {349-363},
Series = {LNCS},
Year = {2014},
}

@article{Meertens92,
author = {Meertens, Lambert},
year = {1992},
@month = {09},
pages = {},
title = {Paramorphisms},
volume = {4},
journal = {Formal Aspects of Computing},
doi = {10.1007/BF01211391}
}

@inproceedings{Paco2013,
author = {Hur, Chung-Kil and Neis, Georg and Dreyer, Derek and Vafeiadis, Viktor},
title = {The Power of Parameterization in Coinductive Proof},
year = {2013},
isbn = {9781450318327},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/2429069.2429093},
doi = {10.1145/2429069.2429093},
booktitle = {Proceedings of the 40th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {193–206},
numpages = {14},
keywords = {interactive theorem proving, lattice theory, simulation, parameterized greatest fixed point, compositionality, coinduction},
location = {Rome, Italy},
series = {POPL ’13}
}

@inproceedings{LiskovSubstitutionPrinciple,
 author = {Liskov, Barbara},
 title = {Keynote Address-Data Abstraction and Hierarchy},
 booktitle = {Addendum to the Proceedings on Object-oriented Programming Systems, Languages and Applications (Addendum)},
 series = {OOPSLA~'87},
 year = {1987},
 isbn = {0-89791-266-7},
 location = {Orlando, Florida, USA},
 pages = {17--34},
 numpages = {18},
 @url = {http://doi.acm.org/10.1145/62138.62141},
 doi = {10.1145/62138.62141},
 acmid = {62141},
 publisher = {ACM},
 address = {New York, NY, USA},
}

@inproceedings{OCamlCopatterns,
 author = {Regis-Gianas, Yann and Laforgue, Paul},
 title = {Copattern-matchings and first-class observations in {OCaml}, with a
                  macro},
 year = {2017},
 booktitle = {Proceedings of the 19th International Symposium on Principles and
                  Practice of Declarative Programming},
 series = {PPDP~'17},
}

@inproceedings{Mendler87,
  author    = {Mendler, Nax P.},
  title     = {Recursive types and type constraints in second-order lambda calculus},
  booktitle = {Logic in Computer Science},
  year      = {1987},
}

@PhDThesis{Mendler88,
  author      = {Mendler, Nax P.},
  title       = {Inductive Definition in Type Theory},
  school      = {Cornell University},
  type        = {{Ph.D.} thesis},
  year        = 1988
}

@article{Bhm1985AutomaticSO,
  title={Automatic Synthesis of Typed Lambda-Programs on Term Algebras},
  author={Corrado B{\"o}hm and Alessandro Berarducci},
  journal={Theoretical Computer Science},
  year={1985},
  volume={39},
  pages={135-154}
}

@article{TarskiFixedPoint,
author = {Alfred Tarski},
title = {{A lattice-theoretical fixpoint theorem and its applications.}},
volume = {5},
journal = {Pacific Journal of Mathematics},
number = {2},
publisher = {Pacific Journal of Mathematics, A Non-profit Corporation},
pages = {285 -- 309},
year = {1955},
doi = {pjm/1103044538},
@URL = {https://doi.org/}
}

@article{KnasterFixedPoint,
  title={Un theoreme sur les functions d'ensembles},
  author={Knaster, Bronis{\l}aw},
  journal={Ann. Soc. Polon. Math.},
  volume={6},
  pages={133--134},
  year={1928}
}

@book{KleeneFixedPoint,
  title={Introduction to Metamathematics},
  author={Kleene, Stephen C.},
  isbn={9780720421033},
  lccn={70097931},
  series={Bibliotheca Mathematica, a Series of Monographs on Pure and},
  year={1971},
  publisher={Wolters-Noordhoff}
}

@phdthesis{Herbelin2005Habilitation,
author = {Hugo Herbelin},
title = {C'est maintenant qu'on calcule : Au coeur de la dualit\'e},
@type = {Habilitation \`{a} diriger les reserches},
type = {Habilitation thesis},
school = {Universit\'{e} Paris 11},
year = 2005,
}

@article{CD78,
  author    = {Mario Coppo and
               Mariangiola Dezani{-}Ciancaglini},
  title     = {A new type assignment for {\(\lambda\)}-terms},
  journal   = {Arch. Math. Log.},
  volume    = 19,
  number    = 1,
  pages     = {139--156},
  year      = 1978,
  @url       = {https://doi.org/10.1007/BF02011875},
  doi       = {10.1007/BF02011875},
}

@InProceedings{S78,
  AUTHOR =       {Sall\'e, P.},
  TITLE =        {Une extension de la th\'eorie des types en lambda-calcul},
  BOOKTITLE =    {Fifth International Conference on Automata, Languages and Programming},
  PAGES =        {398-410},
  YEAR =         1978,
  @EDITOR =       {Ausiello, G. and B\"ohm, C.},
  VOLUME =       62,
  @SERIES =       {Lecture Notes in Computer Science},
  PUBLISHER =    {Springer-Verlag}
}


@InCollection{P80,
  AUTHOR =   {Pottinger, G.},
  TITLE =    {A type assignment for the strongly normalizable
                  $\lambda$-terms},
  BOOKTITLE =    {To H. B. Curry: Essays on Combinatory Logic, Lambda
                  Calculus and Formalism},
  @EDITOR =   {J.~P. Seldin and J.~R. Hindley},
  VOLUME =   {},
  PAGES =    {561--577},
  PUBLISHER =    {Academic Press},
  SERIES =   {},
  ADDRESS =  {London},
  YEAR =     {1980},
}

@inproceedings{DependentIntersection,
author = {Kopylov, Alexei},
title = {Dependent Intersection: A New Way of Defining Records in Type Theory},
year = {2003},
isbn = {0769518842},
publisher = {IEEE Computer Society},
address = {USA},
abstract = {Records and dependent records are a powerful toolfor programming, representing mathematical concepts, andprogram verification. In the last decade several type systemswith records as primitive types were proposed. Thequestion is arose: whether it is possible to define recordtype in existent type theories using standard types withoutintroducing new primitives.It was known that independent records can be defined intype theories with dependent functions or intersection. Onthe other hand dependent records cannot be formed usingstandard types. Hickey introduced a complex notion of verydependent functions to represent dependent records. In thecurrent paper we extend Martin-L\"{o}f's type theory with asimpler type constructor dependent intersection, i.e., the intersectionof two types, where the second type may dependon elements of the first one (not to be confused with the intersectionof a family of types). This new type constructorallows us to define dependent records in a very simple way.It also allows us to define the set type constructor.},
booktitle = {Proceedings of the 18th Annual IEEE Symposium on Logic in Computer Science},
pages = {86},
series = {LICS~'03}
}

@book{Nuprl,
author = {Constable, R. L. and Allen, S. F. and Bromley, H. M. and Cleaveland, W. R. and Cremer, J. F. and Harper, R. W. and Howe, D. J. and Knoblock, T. B. and Mendler, N. P. and Panangaden, P. and Sasaki, J. T. and Smith, S. F.},
title = {Implementing mathematics with the Nuprl proof development system},
year = {1986},
isbn = {0134518322},
publisher = {Prentice-Hall, Inc.},
address = {USA}
}

@InProceedings{Constable1984,
author="Constable, R. L.",
@editor="Clarke, Edmund
and Kozen, Dexter",
title="Mathematics as programming",
booktitle="Logics of Programs",
year="1984",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="116--128",
isbn="978-3-540-38775-6"
}

@phdthesis{LiPhD,
  author = {Li, Nuo},
  title  = {Quotient types in type theory},
  school = {University of Nottingham},
  year   = {2015},
}

@InProceedings{Hofmann1995,
author="Hofmann, Martin",
@editor="Dezani-Ciancaglini, Mariangiola
and Plotkin, Gordon",
title="A simple model for quotient types",
booktitle="Typed Lambda Calculi and Applications",
year=1995,
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="216--234",
abstract="We give an interpretation of quotient types within in a dependent type theory with an impredicative universe of propositions (Calculus of Constructions). In the model, type dependency arises only at the propositional level, therefore universes and large eliminations cannot be interpreted. In exchange, the model is much simpler and more intuitive than the one proposed by the author in [10]. Moreover, we interpret a choice operator for quotient types that, under certain restrictions, allows one to recover a representative from an equivalence class. Since the model is constructed syntactically, the interpretation function from the syntax with quotient types to the model gives rise to a procedure which eliminates quotient types by replacing propositional equality by equality relations defined by induction on the type structure (``book equalities'').",
isbn="978-3-540-49178-1"
}

@book{SangiorgiIntroCoinduction,
author = {Sangiorgi, Davide},
title = {Introduction to Bisimulation and Coinduction},
year = {2011},
isbn = {1107003636, 9781107003637},
publisher = {Cambridge University Press},
address = {New York, NY, USA},
}

@inbook{OrigamiProgramming,
author = {Gibbons, Jeremy},
chapter = {Origami programming},
title = {The Fun of Programming},
@editors = {Gibbons, Jeremy and de Moor, Oege},
year = {2003},
@month = {01},
pages = {41-60},
isbn = {978-0-333-99285-2},
doi = {10.1007/978-1-349-91518-7_3}
}

@article{hughes89,
 author = {Hughes, John},
 title = {Why Functional Programming Matters},
 journal = {Computer Journal},
 volume = {32},
 number = {2},
 year = {1989},
 pages = {98--107},
}

@inproceedings{MFP91,
author = {Meijer, Erik and Fokkinga, Maarten and Paterson, Ross},
title = {Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire},
year = {1991},
isbn = {0387543961},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
booktitle = {Proceedings of the 5th ACM Conference on Functional Programming Languages and Computer Architecture},
pages = {124–144},
numpages = {21},
location = {Cambridge, Massachusetts, USA}
}

@inproceedings{Vene98functionalprogramming,
    author = {Varmo Vene and Tarmo Uustalu},
    title = {Functional programming with apomorphisms (corecursion)},
    booktitle = {Proceedings of the Estonian Academy of Sciences: Physics, Mathematics},
    year = {1998},
    pages = {147--161}
}

@phdthesis{VosMasters,
author = {Vos, Tanja E.~J.},
title = {Program construction and generation based on recursive data types},
year = {1995},
type = {Masters thesis},
school = {Philips Research, Eindhoven},
}

@article{CockettCharity,
author = {J. Robin B. Cockett and Dwight Spencer},
title = {Strong Categorical Datatypes {II:} {A} Term Logic for Categorical Programming},
journal = {Theoretical Computer Science},
volume = {139},
number = {1{\&}2},
pages = {69--113},
year = {1995},
doi = {10.1016/0304-3975(94)00099-5},
@url = {https://doi.org/10.1016/0304-3975(94)00099-5}
}

@misc{AboutCharity,
  title = {About Charity},
  author = {Fukushima, Tom and Cockett, Robin},
  year = 1992,
  @URL = {https://prism.ucalgary.ca/handle/1880/45460},
  doi = {10.11575/PRISM/10182},
  publisher = {PRISM}
}

@inproceedings{AZ_FTfJP13,
author = {Ancona, Davide and Zucca, Elena},
title = {Safe corecursion in {coFJ}},
year = {2013},
isbn = {9781450320429},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/2489804.2489807},
doi = {10.1145/2489804.2489807},
abstract = {In previous work we have presented coFJ, an extension to Featherweight Java that promotes coinductive programming, a sub-paradigm expressly devised to ease high-level programming and reasoning with cyclic data structures.The coFJ language supports cyclic objects and regularly corecursive methods, that is, methods whose invocation terminates not only when the corresponding call trace is finite (as happens with ordinary recursion), but also when such a trace is infinite but cyclic, that is, can be specified by a regular term, or, equivalently, by a finite set of recursive syntactic equations.In coFJ it is not easy to ensure that the invocation of a corecursive method will return a well-defined value, since the recursive equations corresponding to the regular trace of the recursive calls may not admit a (unique) solution; in such cases we say that the value returned by the method call is undetermined.In this paper we propose two new contributions. First, we design a simpler construct for defining corecursive methods and, correspondingly, provide a more intuitive operational semantics. For this coFJ variant, we are able to define a type system that allows the user to specify that certain corecursive methods cannot return an undetermined value; in this way, it is possible to prevent unsafe use of such a value.The operational semantics and the type system of coFJ are fully formalized, and the soundness of the type system is proved.},
booktitle = {Proceedings of the 15th Workshop on Formal Techniques for Java-like Programs},
articleno = {2},
numpages = {7},
keywords = {Java, coinduction, programming paradigms, regular terms},
location = {Montpellier, France},
series = {FTfJP~'13},
}

@inproceedings{AZ-CoLP12,
  author = {Ancona, D. and Zucca, E.},
  title = {Translating Corecursive {Featherweight Java} in
                   Coinductive Logic Programming},
  booktitle = {{Co-LP} 2012 - A workshop on {C}oinductive {L}ogic
                   {P}rogramming},
  abstract = {Corecursive FeatherWeight Java (coFJ) is a recently
                   proposed extension of the calculus FeatherWeight Java
                   (FJ), supporting cyclic objects and regular recursion,
                   and explicitly designed to promote a novel programming
                   paradigm inspired by coinductive Logic Programming
                   (coLP), based on coinductive, rather than inductive,
                   interpretation of recursive function definitions. We
                   present a slightly modified version of coFJ where the
                   application of a coinductive hypothesis can trigger the
                   evaluation of a specific expression at declaration,
                   rather than at use site. Following an approach inspired
                   by abstract compilation, we then show how coFJ can be
                   directly translated into coLP, when coinductive SLD is
                   extended with a similar feature for explicitly solving
                   a goal when a coinductive hypothesis is applied. Such a
                   translation is quite compact and, besides showing the
                   direct relation between coFJ and coinductive Prolog,
                   provides a first prototypical but simple and effective
                   implementation of coFJ.},
  @url = {ftp://ftp.disi.unige.it/person/AnconaD/AZ-CoLP12.pdf},
  keywords = {objects, coinduction, corecursion},
  year = 2012
}

@inproceedings{AZ-FTfJP12,
author = {Ancona, Davide and Zucca, Elena},
title = {Corecursive {Featherweight Java}},
year = {2012},
isbn = {9781450312721},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/2318202.2318205},
doi = {10.1145/2318202.2318205},
abstract = {Despite cyclic data structures occur often in many application domains, object-oriented programming languages provide poor abstraction mechanisms for dealing with cyclic objects.Such a deficiency is reflected also in the research on theoretical foundation of object-oriented languages; for instance, Featherweigh Java (FJ), which is one of the most widespread object-oriented calculi, does not allow creation and manipulation of cyclic objects.We propose an extension to Featherweight Java, called COFJ, where it is possible to define cyclic objects, abstractly corresponding to regular terms, and where an abstraction mechanism, called regular corecursion, is provided for supporting implementation of coinductive operations on cyclic objects.We formally define the operational semantics of COFJ, and provide a handful of examples showing the expressive power of regular corecursion; such a mechanism promotes a novel programming style particularly well-suited for implementing cyclic data structures, and for supporting coinductive reasoning.},
booktitle = {Proceedings of the 14th Workshop on Formal Techniques for Java-like Programs},
pages = {3–10},
numpages = {8},
keywords = {Java-like languages, coinduction, programming paradigms, regular terms},
location = {Beijing, China},
series = {FTfJP~'12},
}

@inproceedings{LiquidHaskell22,
author = {Mastorou, Lykourgos and Papaspyrou, Nikolaos and Vazou, Niki},
title = {Coinduction Inductively: Mechanizing Coinductive Proofs in Liquid Haskell},
year = {2022},
isbn = {9781450394383},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/3546189.3549922},
doi = {10.1145/3546189.3549922},
abstract = {Liquid Haskell is an inductive verifier that  cannot reason about codata.  In this work we present two alternative approaches,  namely indexed and constructive coinduction,  to consistently encode coinductive proofs in Liquid Haskell.  The intuition is that indices can be used to enforce the base case in  the setting of classical logic and the guardedness check in the constructive proofs.  We use our encodings to machine check 10 coinductive proofs,  about unary and binary predicates on infinite streams and lists,  showcasing how an inductive verifier can be used to check  coinductive properties of Haskell code.},
booktitle = {Proceedings of the 15th ACM SIGPLAN International Haskell Symposium},
pages = {1–12},
numpages = {12},
keywords = {refinement types, theorem proving, coinduction},
location = {Ljubljana, Slovenia},
series = {Haskell 2022}
}

@incollection{pous:hal2012,
  TITLE = {{Enhancements of the bisimulation proof method}},
  AUTHOR = {Pous, Damien and Sangiorgi, Davide},
  @URL = {https://inria.hal.science/hal-00909391},
  BOOKTITLE = {{Advanced Topics in Bisimulation and Coinduction}},
  @EDITOR = {Davide Sangiorgi and Jan Rutten},
  PUBLISHER = {{Cambridge University Press}},
  YEAR = {2012},
  HAL_ID = {hal-00909391},
  HAL_VERSION = {v1},
}


@article{Barwise97,
author = {Barwise, Jon and Moss, Lawrence},
title = {Vicious circles. On the mathematics of non-wellfounded phenomena},
year={1997},
journal = {The Journal of Symbolic Logic},
number = {3},
volume = {62},
pages={1039--1040},
DOI={10.2307/2275587},
@url={https://doi.org/10.2307/2275587},
publisher={Cambridge University Press}, 
}

@inproceedings{Leroy1998SecurityPO,
  author       = {Xavier Leroy and
                  Fran{\c{c}}ois Rouaix},
  @editor       = {David B. MacQueen and
                  Luca Cardelli},
  title        = {Security Properties of Typed Applets},
  booktitle    = {{POPL}~'98, Proceedings of the 25th {ACM} {SIGPLAN-SIGACT} Symposium
                  on Principles of Programming Languages, San Diego, CA, USA, January
                  19-21, 1998},
  pages        = {391--403},
  publisher    = {{ACM}},
  year         = {1998},
  @url          = {https://doi.org/10.1145/268946.268979},
  doi          = {10.1145/268946.268979},
}

@inproceedings{Appel2000,
  author       = {Andrew W. Appel and
                  Amy P. Felty},
  @editor       = {Mark N. Wegman and
                  Thomas W. Reps},
  title        = {A Semantic Model of Types and Machine Instuctions for Proof-Carrying
                  Code},
  booktitle    = {{POPL} 2000, Proceedings of the 27th {ACM} {SIGPLAN-SIGACT} Symposium
                  on Principles of Programming Languages, Boston, Massachusetts, USA,
                  January 19-21, 2000},
  pages        = {243--253},
  publisher    = {{ACM}},
  year         = {2000},
  @url          = {https://doi.org/10.1145/325694.325727},
  doi          = {10.1145/325694.325727},
}

@inproceedings{FritzLasse2011,
author = {Henglein, Fritz and Nielsen, Lasse},
title = {Regular Expression Containment: Coinductive Axiomatization and Computational Interpretation},
year = {2011},
isbn = {9781450304900},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/1926385.1926429},
doi = {10.1145/1926385.1926429},
booktitle = {Proceedings of the 38th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {385–398},
numpages = {14},
location = {Austin, Texas, USA},
series = {POPL~'11},
}

@article{ITrees,
  author       = {Li{-}yao Xia and
                  Yannick Zakowski and
                  Paul He and
                  Chung{-}Kil Hur and
                  Gregory Malecha and
                  Benjamin C. Pierce and
                  Steve Zdancewic},
  title        = {Interaction trees: representing recursive and impure programs in Coq},
  journal      = {Proceedings of the {ACM} on Programming Languages},
  volume       = {4},
  number       = {{POPL}},
  pages        = {51:1--51:32},
  year         = {2020},
  @url          = {https://doi.org/10.1145/3371119},
  doi          = {10.1145/3371119},
}

@article{ITreeDijkstra,
  author       = {Lucas Silver and
                  Steve Zdancewic},
  title        = {Dijkstra monads forever: termination-sensitive specifications for
                  interaction trees},
  journal      = {Proceedings of the {ACM} on Programming Languages},
  volume       = {5},
  number       = {{POPL}},
  pages        = {1--28},
  year         = {2021},
  @url          = {https://doi.org/10.1145/3434307},
  doi          = {10.1145/3434307},
}

@inproceedings{ITreeHTTP,
  author       = {Hengchu Zhang and
                  Wolf Honor{\'{e}} and
                  Nicolas Koh and
                  Yao Li and
                  Yishuai Li and
                  Li{-}yao Xia and
                  Lennart Beringer and
                  William Mansky and
                  Benjamin C. Pierce and
                  Steve Zdancewic},
  @editor       = {Liron Cohen and
                  Cezary Kaliszyk},
  title        = {Verifying an {HTTP} Key-Value Server with Interaction Trees and {VST}},
  booktitle    = {12th International Conference on Interactive Theorem Proving, {ITP}
                  2021, June 29 to July 1, 2021, Rome, Italy (Virtual Conference)},
  series       = {LIPIcs},
  volume       = {193},
  pages        = {32:1--32:19},
  publisher    = {Schloss Dagstuhl - Leibniz-Zentrum f{\"{u}}r Informatik},
  year         = {2021},
  @url          = {https://doi.org/10.4230/LIPIcs.ITP.2021.32},
  doi          = {10.4230/LIPICS.ITP.2021.32},
}

@inproceedings{ITreeNoninterference,
  author       = {Lucas Silver and
                  Paul He and
                  Ethan Cecchetti and
                  Andrew K. Hirsch and
                  Steve Zdancewic},
  @editor       = {Karim Ali and
                  Guido Salvaneschi},
  title        = {Semantics for Noninterference with Interaction Trees},
  booktitle    = {37th European Conference on Object-Oriented Programming, {ECOOP} 2023,
                  July 17-21, 2023, Seattle, Washington, United States},
  series       = {LIPIcs},
  volume       = {263},
  pages        = {29:1--29:29},
  publisher    = {Schloss Dagstuhl - Leibniz-Zentrum f{\"{u}}r Informatik},
  year         = {2023},
  @url          = {https://doi.org/10.4230/LIPIcs.ECOOP.2023.29},
  doi          = {10.4230/LIPICS.ECOOP.2023.29},
}

@inproceedings{ITreeNetworkServer,
author = {Koh, Nicolas and Li, Yao and Li, Yishuai and Xia, Li-yao and Beringer, Lennart and Honor\'{e}, Wolf and Mansky, William and Pierce, Benjamin C. and Zdancewic, Steve},
title = {From C to interaction trees: specifying, verifying, and testing a networked server},
year = {2019},
isbn = {9781450362221},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/3293880.3294106},
doi = {10.1145/3293880.3294106},
abstract = {We present the first formal verification of a networked server implemented in C. Interaction trees, a general structure for representing reactive computations, are used to tie together disparate verification and testing tools (Coq, VST, and QuickChick) and to axiomatize the behavior of the operating system on which the server runs (CertiKOS). The main theorem connects a specification of acceptable server behaviors, written in a straightforward “one client at a time” style, with the CompCert semantics of the C program. The variability introduced by low-level buffering of messages and interleaving of multiple TCP connections is captured using network refinement, a variant of observational refinement.},
booktitle = {Proceedings of the 8th ACM SIGPLAN International Conference on Certified Programs and Proofs},
pages = {234–248},
numpages = {15},
keywords = {QuickChick, TCP, VST, formal verification, interaction trees, network refinement, testing},
location = {Cascais, Portugal},
series = {CPP 2019}
}

@inproceedings{Bonchi13,
  author       = {Filippo Bonchi and
                  Damien Pous},
  @editor       = {Roberto Giacobazzi and
                  Radhia Cousot},
  title        = {Checking {NFA} equivalence with bisimulations up to congruence},
  booktitle    = {The 40th Annual {ACM} {SIGPLAN-SIGACT} Symposium on Principles of
                  Programming Languages, {POPL}~'13, Rome, Italy - January 23 - 25,
                  2013},
  pages        = {457--468},
  publisher    = {{ACM}},
  year         = {2013},
  @url          = {https://doi.org/10.1145/2429069.2429124},
  doi          = {10.1145/2429069.2429124},
}

@inproceedings{Foster2015,
  author       = {Nate Foster and
                  Dexter Kozen and
                  Mae Milano and
                  Alexandra Silva and
                  Laure Thompson},
  @editor       = {Sriram K. Rajamani and
                  David Walker},
  title        = {A Coalgebraic Decision Procedure for NetKAT},
  booktitle    = {Proceedings of the 42nd Annual {ACM} {SIGPLAN-SIGACT} Symposium on
                  Principles of Programming Languages, {POPL} 2015, Mumbai, India, January
                  15-17, 2015},
  pages        = {343--355},
  publisher    = {{ACM}},
  year         = {2015},
  @url          = {https://doi.org/10.1145/2676726.2677011},
  doi          = {10.1145/2676726.2677011},
}

@inproceedings{DalLago2014,
  author       = {Ugo Dal Lago and
                  Davide Sangiorgi and
                  Michele Alberti},
  @editor       = {Suresh Jagannathan and
                  Peter Sewell},
  title        = {On coinductive equivalences for higher-order probabilistic functional
                  programs},
  booktitle    = {The 41st Annual {ACM} {SIGPLAN-SIGACT} Symposium on Principles of
                  Programming Languages, {POPL}~'14, San Diego, CA, USA, January 20-21,
                  2014},
  pages        = {297--308},
  publisher    = {{ACM}},
  year         = {2014},
  @url          = {https://doi.org/10.1145/2535838.2535872},
  doi          = {10.1145/2535838.2535872},
}

@inproceedings{Derek2012,
  author       = {Chung{-}Kil Hur and
                  Derek Dreyer and
                  Georg Neis and
                  Viktor Vafeiadis},
  @editor       = {John Field and
                  Michael Hicks},
  title        = {The marriage of bisimulations and {Kripke} logical relations},
  booktitle    = {Proceedings of the 39th {ACM} {SIGPLAN-SIGACT} Symposium on Principles
                  of Programming Languages, {POPL} 2012, Philadelphia, Pennsylvania,
                  USA, January 22-28, 2012},
  pages        = {59--72},
  publisher    = {{ACM}},
  year         = {2012},
  @url          = {https://doi.org/10.1145/2103656.2103666},
  doi          = {10.1145/2103656.2103666},
}

@InProceedings{Leino2014,
author="Leino, K. Rustan M.  and Moskal, Micha{\l}",
@editor="Jones, Cliff and Pihlajasaari, Pekka and Sun, Jun",
title="Co-induction Simply",
booktitle="FM 2014: Formal Methods",
year="2014",
publisher="Springer International Publishing",
address="Cham",
pages="382--398",
abstract="This paper shows that an SMT-based program verifier can support reasoning about co-induction---handling infinite data structures, lazy function calls, and user-defined properties defined as greatest fix-points, as well as letting users write co-inductive proofs. Moreover, the support can be packaged to provide a simple user experience. The paper describes the features for co-induction in the language and verifier Dafny, defines their translation into input for a first-order SMT solver, and reports on some encouraging initial experience.",
isbn="978-3-319-06410-9"
}

@book{Chlipala2013,
author = {Chlipala, Peter},
title = {Certified Programming with Dependent Types: A Pragmatic Introduction to the {Coq} Proof Assistant},
year = {2013},
publisher = {MIT Press}
}

@InProceedings{Gimenez96,
author="Gim{\'e}nez, Eduardo",
@editor="Berardi, Stefano
and Coppo, Mario",
title="An application of co-inductive types in {Coq}: Verification of the alternating bit protocol",
booktitle="Types for Proofs and Programs",
year=1996,
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="135--152",
abstract="We describe an experience concerning the implementation and use of co-inductive types in the proof @editor Coq. Co-inductive types are recursive types which, opposite to inductive ones, may be inhabited by infinite objects. In order to illustrate their use in Coq, we describe an axiomatisation of a calculus of broadcasting systems where non-ending processes are represented using infinite objects. This calculus is then used for developing a verification proof of the alternating bit protocol.",
isbn="978-3-540-70722-6"
}

@inproceedings{FStar,
author = {Swamy, Nikhil and Hriţcu, Cătălin and Keller, Chantal and Rastogi, Aseem and Delignat-Lavaud, Antoine and Forest, Simon and Bhargavan, Karthikeyan and Fournet, Cédric and Strub,  	Pierre-Yves and Kohlweiss, Markulf and Zinzindohoue, Jean-Karim and Zanella-Béguelin, Santiago},
title = {Dependent Types and Multi-Monadic Effects in F*},
booktitle = {POPL~'16 Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
year = {2016},
@month = {January},
abstract = {We present a new, completely redesigned, version of F*, a language that works both as a proof assistant as well as a general-purpose, verification-oriented, effectful programming language. In support of these complementary roles, F* is a dependently typed, higher-order, call-by-value language with _primitive_ effects including state, exceptions, divergence and IO. Although primitive, programmers choose the granularity at which to specify effects by equipping each effect with a monadic, predicate transformer semantics. F* uses this to efficiently compute weakest preconditions and discharges the resulting proof obligations using a combination of SMT solving and manual proofs. Isolated from the effects, the core of F* is a language of pure functions used to write specifications and proof terms---its consistency is maintained by a semantic termination check based on a well-founded order. We evaluate our design on more than 55,000 lines of F* we have authored in the last year, focusing on three main case studies. Showcasing its use as a general-purpose programming language, F* is programmed (but not verified) in F*, and bootstraps in both OCaml and F#. Our experience confirms F*'s pay-as-you-go cost model: writing idiomatic ML-like code with no finer specifications imposes no user burden. As a verification-oriented language, our most significant evaluation of F* is in verifying several key modules in an implementation of the TLS-1.2 protocol standard. For the modules we considered, we are able to prove more properties, with fewer annotations using F* than in a prior verified implementation of TLS-1.2. Finally, as a proof assistant, we discuss our use of F* in mechanizing the metatheory of a range of lambda calculi, starting from the simply typed lambda calculus to System F-omega and even micro-F*, a sizeable fragment of F* itself---these proofs make essential use of F*'s flexible combination of SMT automation and constructive proofs, enabling a tactic-free style of programming and proving at a relatively large scale.},
@url = {https://www.microsoft.com/en-us/research/publication/dependent-types-multi-monadic-effects-f/},
pages = {256-270},
isbn = {978-1-4503-3549-2},
edition = {POPL~'16 Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
}

@techreport{IndexedEffects,
  TITLE = {{Programming and Proving with Indexed Effects}},
  AUTHOR = {Rastogi, Aseem and Mart{\'i}nez, Guido and Fromherz, Aymeric and Ramananandro, Tahina and Swamy, Nikhil},
  @URL = {https://inria.hal.science/hal-04256360},
  INSTITUTION = {{Microsoft Research}},
  YEAR = {2020},
  @MONTH = Oct,
  PDF = {https://inria.hal.science/hal-04256360/file/indexedeffects.pdf},
  HAL_ID = {hal-04256360},
  HAL_VERSION = {v1},
}

@article{SteelCore,
author = {Swamy, Nikhil and Rastogi, Aseem and Fromherz, Aymeric and Merigoux, Denis and Ahman, Danel and Mart\'{\i}nez, Guido},
title = {SteelCore: an extensible concurrent separation logic for effectful dependently typed programs},
year = {2020},
issue_date = {August 2020},
publisher = {ACM},
address = {New York, NY, USA},
volume = {4},
number = {ICFP},
@url = {https://doi.org/10.1145/3409003},
doi = {10.1145/3409003},
abstract = {Much recent research has been devoted to modeling effects within type theory. Building on this work, we observe that effectful type theories can provide a foundation on which to build semantics for more complex programming constructs and program logics, extending the reasoning principles that apply within the host effectful type theory itself. Concretely, our main contribution is a semantics for concurrent separation logic (CSL) within the F⋆ proof assistant in a manner that enables dependently typed, effectful F⋆ programs to make use of concurrency and to be specified and verified using a full-featured, extensible CSL. In contrast to prior approaches, we directly derive the partial-correctness Hoare rules for CSL from the denotation of computations in the effectful semantics of non-deterministically interleaved atomic actions. Demonstrating the flexibility of our semantics, we build generic, verified libraries that support various concurrency constructs, ranging from dynamically allocated, storable spin locks, to protocol-indexed channels. We conclude that our effectful semantics provides a simple yet expressive basis on which to layer domain-specific languages and logics for verified, concurrent programming.},
journal = {Proceedings of the ACM on Programming Languages},
@month = {aug},
articleno = {121},
numpages = {30},
keywords = {Concurrency, Program Proofs, Separation Logic}
}

@inproceedings{VerifyingDijkstraMonad,
author = {Swamy, Nikhil and Weinberger, Joel and Schlesinger, Cole and Chen, Juan and Livshits, Benjamin},
title = {Verifying higher-order programs with the dijkstra monad},
year = {2013},
isbn = {9781450320146},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/2491956.2491978},
doi = {10.1145/2491956.2491978},
abstract = {Modern programming languages, ranging from Haskell and ML, to JavaScript, C# and Java, all make extensive use of higher-order state. This paper advocates a new verification methodology for higher-order stateful programs, based on a new monad of predicate transformers called the Dijkstra monad.Using the Dijkstra monad has a number of benefits. First, the monad naturally yields a weakest pre-condition calculus. Second, the computed specifications are structurally simpler in several ways, e.g., single-state post-conditions are sufficient (rather than the more complex two-state post-conditions). Finally, the monad can easily be varied to handle features like exceptions and heap invariants, while retaining the same type inference algorithm.We implement the Dijkstra monad and its type inference algorithm for the F* programming language. Our most extensive case study evaluates the Dijkstra monad and its F* implementation by using it to verify JavaScript programs.Specifically, we describe a tool chain that translates programs in a subset of JavaScript decorated with assertions and loop invariants to F*. Once in F*, our type inference algorithm computes verification conditions and automatically discharges their proofs using an SMT solver. We use our tools to prove that a core model of the JavaScript runtime in F* respects various invariants and that a suite of JavaScript source programs are free of runtime errors.},
booktitle = {Proceedings of the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {387–398},
numpages = {12},
keywords = {dynamic languages, hoare monad, predicate transformer, refinement types},
location = {Seattle, Washington, USA},
series = {PLDI~'13}
}

@article{Next700CompilerCorrectness,
author = {Patterson, Daniel and Ahmed, Amal},
title = {The next 700 compiler correctness theorems (functional pearl)},
year = {2019},
issue_date = {August 2019},
publisher = {ACM},
address = {New York, NY, USA},
volume = {3},
number = {ICFP},
@url = {https://doi.org/10.1145/3341689},
doi = {10.1145/3341689},
abstract = {Compiler correctness is an old problem, with results stretching back beyond the last half-century. Founding the field, John McCarthy and James Painter set out to build a "completely trustworthy compiler". And yet, until quite recently, even despite truly impressive verification efforts, the theorems being proved were only about the compilation of whole programs, a theoretically quite appealing but practically unrealistic simplification. For a compiler correctness theorem to assure complete trust, the theorem must reflect the reality of how the compiler will be used. There has been much recent work on more realistic "compositional" compiler correctness aimed at proving correct compilation of components while supporting linking with components compiled from different languages using different compilers. However, the variety of theorems, stated in remarkably different ways, raises questions about what researchers even mean by a "compiler is correct." In this pearl, we develop a new framework with which to understand compiler correctness theorems in the presence of linking, and apply it to understanding and comparing this diversity of results. In doing so, not only are we better able to assess their relative strengths and weaknesses, but gain insight into what we as a community should expect from compiler correctness theorems of the future.},
journal = {Proceedings of the ACM on Programming Languages},
@month = {jul},
articleno = {85},
numpages = {29},
keywords = {compilers, verification}
}

@unpublished{DissectionOfL,
  author = {Arnaud Spiwack},
  title = {A Dissection of {L}},
  year  = {2014},
  note = {Unpublished manuscript.},
	@url = {https://assert-false.science/arnaud/papers/A%20dissection%20of%20L.pdf},
}

@inproceedings{PierceTurner1998LocalTypeInference,
  author       = {Benjamin C. Pierce and
                  David N. Turner},
  @editor       = {David B. MacQueen and
                  Luca Cardelli},
  title        = {Local Type Inference},
  booktitle    = {{POPL}~'98, Proceedings of the 25th {ACM} {SIGPLAN-SIGACT} Symposium
                  on Principles of Programming Languages, San Diego, CA, USA, January
                  19-21, 1998},
  pages        = {252--265},
  publisher    = {{ACM}},
  year         = {1998},
  @url          = {https://doi.org/10.1145/268946.268967},
  doi          = {10.1145/268946.268967},
}

@article{PierceTurner2000LocalTypeInference,
author = {Pierce, Benjamin C. and Turner, David N.},
title = {Local type inference},
year = {2000},
issue_date = {Jan. 2000},
publisher = {ACM},
address = {New York, NY, USA},
volume = {22},
number = {1},
issn = {0164-0925},
@url = {https://doi.org/10.1145/345099.345100},
doi = {10.1145/345099.345100},
abstract = {We study two partial type inference methods for a language combining subtyping and impredicative polymorphism. Both methods are local in the sense that missing annotations are recovered using only information from adjacent nodes in the syntax tree, without long-distance constraints such as unification variables. One method infers type arguments in polymorphic applications using a local constraint solver. The other infers annotations on bound variables in function abstractions by propagating type constraints downward from enclosing application nodes. We motivate our design choices by a statistical analysis of the uses of type inference in a sizable body of existing ML code.},
journal = {ACM Transactions on Programming Languages and Systems},
@month = {jan},
pages = {1–44},
numpages = {44},
keywords = {type inference, subtyping, polymorphism}
}

@article{DK2021Bidirectional,
author = {Dunfield, Jana and Krishnaswami, Neel},
title = {Bidirectional Typing},
year = {2021},
issue_date = {June 2022},
publisher = {ACM},
address = {New York, NY, USA},
volume = {54},
number = {5},
issn = {0360-0300},
@url = {https://doi.org/10.1145/3450952},
doi = {10.1145/3450952},
abstract = {Bidirectional typing combines two modes of typing: type checking, which checks that a program satisfies a known type, and type synthesis, which determines a type from the program. Using checking enables bidirectional typing to support features for which inference is undecidable; using synthesis enables bidirectional typing to avoid the large annotation burden of explicitly typed languages. In addition, bidirectional typing improves error locality. We highlight the design principles that underlie bidirectional type systems, survey the development of bidirectional typing from the prehistoric period before Pierce and Turner’s local type inference to the present day, and provide guidance for future investigations.},
journal = {ACM Computing Surveys},
@month = {may},
articleno = {98},
numpages = {38},
keywords = {type inference, Type checking}
}

@inproceedings{DP2004Tridirectional,
author = {Dunfield, Jana and Pfenning, Frank},
title = {Tridirectional typechecking},
year = {2004},
isbn = {158113729X},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/964001.964025},
doi = {10.1145/964001.964025},
abstract = {In prior work we introduced a pure type assignment system that encompasses a rich set of property types, including intersections, unions, and universally and existentially quantified dependent types. This system was shown sound with respect to a call-by-value operational semantics with effects, yet is inherently undecidable.In this paper we provide a decidable formulation for this system based on bidirectional checking, combining type synthesis and analysis following logical principles. The presence of unions and existential quantification requires the additional ability to visit subterms in evaluation position before the context in which they occur, leading to a tridirectional type system. While soundness with respect to the type assignment system is immediate, completeness requires the novel concept of contextual type annotations, introducing a notion from the study of principal typings into the source program.},
booktitle = {Proceedings of the 31st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {281–292},
numpages = {12},
keywords = {union types, type refinements, intersection types, dependent types},
location = {Venice, Italy},
series = {POPL~'04}
}

@inproceedings{AMO2012DOT,
  title={Dependent object types},
  author={Amin, Nada and Moors, Adriaan and Odersky, Martin},
  booktitle={19th International Workshop on Foundations of Object-Oriented Languages},
  year={2012}
}

@inproceedings{ARO2014FoundationsPDT,
author = {Amin, Nada and Rompf, Tiark and Odersky, Martin},
title = {Foundations of path-dependent types},
year = {2014},
isbn = {9781450325851},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/2660193.2660216},
doi = {10.1145/2660193.2660216},
abstract = {A scalable programming language is one in which the same concepts can describe small as well as large parts. Towards this goal, Scala unifies concepts from object and module systems. An essential ingredient of this unification is the concept of objects with type members, which can be referenced through path-dependent types. Unfortunately, path-dependent types are not well-understood, and have been a roadblock in grounding the Scala type system on firm theory.We study several calculi for path-dependent types. We present DOT which captures the essence - DOT stands for Dependent Object Types. We explore the design space bottom-up, teasing apart inherent from accidental complexities, while fully mechanizing our models at each step. Even in this simple setting, many interesting patterns arise from the interaction of structural and nominal features.Whereas our simple calculus enjoys many desirable and intuitive properties, we demonstrate that the theory gets much more complicated once we add another Scala feature, type refinement, or extend the subtyping relation to a lattice. We discuss possible remedies and trade-offs in modeling type systems for Scala-like languages.},
booktitle = {Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages \& Applications},
pages = {233–249},
numpages = {17},
keywords = {calculus, dependent types, objects},
location = {Portland, Oregon, USA},
series = {OOPSLA~'14}
}

@article{RompfAmin2015FtoDOT,
  title={From F to DOT: Type Soundness Proofs with Definitional Interpreters},
  author={Tiark Rompf and Nada Amin},
  journal={ArXiv},
  year={2015},
  volume={abs/1510.05216},
  @url={https://api.semanticscholar.org/CorpusID:6182675}
}

@Inbook{EssenceOfDOT,
author="Amin, Nada
and Gr{\"u}tter, Samuel
and Odersky, Martin
and Rompf, Tiark
and Stucki, Sandro",
@editor="Lindley, Sam
and McBride, Conor
and Trinder, Phil
and Sannella, Don",
title="The Essence of Dependent Object Types",
bookTitle="A List of Successes That Can Change the World: Essays Dedicated to Philip Wadler on the Occasion of His 60th Birthday",
year="2016",
publisher="Springer International Publishing",
address="Cham",
pages="249--272",
abstract="Focusing on path-dependent types, the paper develops foundations for Scala from first principles. Starting from a simple calculus D{\$}{\$}{\_}{\{}<:{\}}{\$}{\$}<:of dependent functions, it adds records, intersections and recursion to arrive at DOT, a calculus for dependent object types. The paper shows an encoding of System F with subtyping in D{\$}{\$}{\_}{\{}<:{\}}{\$}{\$}<:and demonstrates the expressiveness of DOT by modeling a range of Scala constructs in it.",
isbn="978-3-319-30936-1",
doi="10.1007/978-3-319-30936-1_14",
@url="https://doi.org/10.1007/978-3-319-30936-1_14"
}

@phdthesis{AminPhD,
  author       = {Nada Amin},
  title        = {Dependent Object Types},
  school       = {EPFL, Switzerland},
  year         = {2016},
  @url          = {https://doi.org/10.5075/epfl-thesis-7156},
  doi          = {10.5075/EPFL-THESIS-7156},
}

@inproceedings{RompfAmin2016SoundnessDOT,
author = {Rompf, Tiark and Amin, Nada},
title = {Type soundness for dependent object types (DOT)},
year = {2016},
isbn = {9781450344449},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/2983990.2984008},
doi = {10.1145/2983990.2984008},
abstract = {Scala’s type system unifies aspects of ML modules, object- oriented, and functional programming. The Dependent Object Types (DOT) family of calculi has been proposed as a new theoretic foundation for Scala and similar expressive languages. Unfortunately, type soundness has only been established for restricted subsets of DOT. In fact, it has been shown that important Scala features such as type refinement or a subtyping relation with lattice structure break at least one key metatheoretic property such as environment narrowing or invertible subtyping transitivity, which are usually required for a type soundness proof. The main contribution of this paper is to demonstrate how, perhaps surprisingly, even though these properties are lost in their full generality, a rich DOT calculus that includes recursive type refinement and a subtyping lattice with intersection types can still be proved sound. The key insight is that subtyping transitivity only needs to be invertible in code paths executed at runtime, with contexts consisting entirely of valid runtime objects, whereas inconsistent subtyping contexts can be permitted for code that is never executed.},
booktitle = {Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications},
pages = {624–641},
numpages = {18},
keywords = {DOT, Scala, dependent object types, soundness},
location = {Amsterdam, Netherlands},
series = {OOPSLA 2016}
}

@inproceedings{AminRompf2017SoundnessInterp,
author = {Amin, Nada and Rompf, Tiark},
title = {Type soundness proofs with definitional interpreters},
year = {2017},
isbn = {9781450346603},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/3009837.3009866},
doi = {10.1145/3009837.3009866},
abstract = {While type soundness proofs are taught in every graduate PL class, the gap between realistic languages and what is accessible to formal proofs is large. In the case of Scala, it has been shown that its formal model, the Dependent Object Types (DOT) calculus, cannot simultaneously support key metatheoretic properties such as environment narrowing and subtyping transitivity, which are usually required for a type soundness proof. Moreover, Scala and many other realistic languages lack a general substitution property. The first contribution of this paper is to demonstrate how type soundness proofs for advanced, polymorphic, type systems can be carried out with an operational semantics based on high-level, definitional interpreters, implemented in Coq. We present the first mechanized soundness proofs in this style for System F and several extensions, including mutable references. Our proofs use only straightforward induction, which is significant, as the combination of big-step semantics, mutable references, and polymorphism is commonly believed to require coinductive proof techniques. The second main contribution of this paper is to show how DOT-like calculi emerge from straightforward generalizations of the operational aspects of F, exposing a rich design space of calculi with path-dependent types inbetween System F and DOT, which we dub the System D Square. By working directly on the target language, definitional interpreters can focus the design space and expose the invariants that actually matter at runtime. Looking at such runtime invariants is an exciting new avenue for type system design.},
booktitle = {Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages},
pages = {666–679},
numpages = {14},
keywords = {type soundness, dependent object types, Scala, Definitional interpreters, DOT},
location = {Paris, France},
series = {POPL~'17}
}

@article{RL2019PathToDOT,
author = {Rapoport, Marianna and Lhot\'{a}k, Ond\v{r}ej},
title = {A path to DOT: formalizing fully path-dependent types},
year = {2019},
issue_date = {October 2019},
publisher = {ACM},
address = {New York, NY, USA},
volume = {3},
number = {OOPSLA},
@url = {https://doi.org/10.1145/3360571},
doi = {10.1145/3360571},
abstract = {The Dependent Object Types (DOT) calculus aims to formalize the Scala programming language with a focus on path-dependent types — types such as x.a1… an.T that depend on the runtime value of a path x.a1… an to an object. Unfortunately, existing formulations of DOT can model only types of the form x.A which depend on variables rather than general paths. This restriction makes it impossible to model nested module dependencies. Nesting small components inside larger ones is a necessary ingredient of a modular, scalable language. DOT’s variable restriction thus undermines its ability to fully formalize a variety of programming-language features including Scala’s module system, family polymorphism, and covariant specialization. This paper presents the pDOT calculus, which generalizes DOT to support types that depend on paths of arbitrary length, as well as singleton types to track path equality. We show that naive approaches to add paths to DOT make it inherently unsound, and present necessary conditions for such a calculus to be sound. We discuss the key changes necessary to adapt the techniques of the DOT soundness proofs so that they can be applied to pDOT. Our paper comes with a Coq-mechanized type-safety proof of pDOT. With support for paths of arbitrary length, pDOT can realize DOT’s full potential for formalizing Scala-like calculi.},
journal = {Proceedings of the ACM on Programming Languages},
@month = {oct},
articleno = {145},
numpages = {29},
keywords = {DOT, Scala, dependent types, paths}
}

@article{MPAG2019SubtypingDOT,
author = {Mackay, Julian and Potanin, Alex and Aldrich, Jonathan and Groves, Lindsay},
title = {Decidable subtyping for path dependent types},
year = {2019},
issue_date = {January 2020},
publisher = {ACM},
address = {New York, NY, USA},
volume = {4},
number = {POPL},
@url = {https://doi.org/10.1145/3371134},
doi = {10.1145/3371134},
abstract = {Path dependent types have long served as an expressive component of the Scala programming language. They allow for the modelling of both bounded polymorphism and a degree of nominal subtyping. Nominality in turn provides the ability to capture first class modules. Thus a single language feature gives rise to a rich array of expressiveness. Recent work has proven path dependent types sound in the presence of both intersection and recursive types, but unfortunately typing remains undecidable, posing problems for programmers who rely on the results of type checkers. The Wyvern programming language is an object oriented language with path dependent types, recursive types and first class modules. In this paper we define two variants of Wyvern that feature decidable typing, along with machine checked proofs of decidability. Despite the restrictions, our approaches retain the ability to encode the parameteric polymorphism of Java generics along with many idioms of the Scala module system.},
journal = {Proceedings of the ACM on Programming Languages},
@month = {dec},
articleno = {66},
numpages = {27},
keywords = {Wyvern, Subtyping, Structural Subtyping, Scala, Path Dependent Types, Object Oriented Languages, Nominal Subtyping, Language Design, Functional Languages, Decidability}
}

@article{PlotkinPower2003,
  author       = {Gordon D. Plotkin and
                  John Power},
  title        = {Algebraic Operations and Generic Effects},
  journal      = {Appl. Categorical Struct.},
  volume       = {11},
  number       = {1},
  pages        = {69--94},
  year         = {2003},
  @url          = {https://doi.org/10.1023/A:1023064908962},
  doi          = {10.1023/A:1023064908962},
}

@article{PlotkinPretnar2013,
  author       = {Gordon D. Plotkin and
                  Matija Pretnar},
  title        = {Handling Algebraic Effects},
  journal      = {Logical Methods in Computer Science},
  volume       = {9},
  number       = {4},
  year         = {2013},
  @url          = {https://doi.org/10.2168/LMCS-9(4:23)2013},
  doi          = {10.2168/LMCS-9(4:23)2013},
}

@inproceedings{CongAsai2023,
author = {Cong, Youyou and Asai, Kenichi},
title = {Understanding Algebraic Effect Handlers via Delimited Control Operators},
year = {2023},
isbn = {978-3-031-21313-7},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
@url = {https://doi.org/10.1007/978-3-031-21314-4_4},
doi = {10.1007/978-3-031-21314-4_4},
abstract = {Algebraic effects and handlers are a powerful and convenient abstraction for user-defined effects. We aim to understand effect handlers through the lens of control operators, a similar but more well-studied tool for expressing effects. In this paper, we establish two program transformations and a type system for effect handlers, all by reusing the existing results about control operators and their relationship to effect handlers.},
booktitle = {Trends in Functional Programming: 23rd International Symposium, TFP 2022, Virtual Event, March 17–18, 2022, Revised Selected Papers},
pages = {59–79},
numpages = {21},
keywords = {Type systems, CPS translation, Macro translation, Delimited control operators, Algebraic effects and handlers}
}

@inproceedings{ICM2023,
author = {Ikemori, Kazuki and Cong, Youyou and Masuhara, Hidehiko},
title = {Typed Equivalence of Labeled Effect Handlers and Labeled Delimited Control Operators},
year = {2023},
isbn = {9798400708121},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/3610612.3610616},
doi = {10.1145/3610612.3610616},
abstract = {Algebraic effect handlers and delimited control operators are language facilities for expressing computational effects. Their labeled variations can express multiple kinds of exceptions, multiple states, and so on. We prove that labeled effect handlers and labeled control operators have equal expressive power. To show this, we develop a type-sound calculus for each facility and define macro translations between the typed calculi. The established equivalence can be used to understand and implement one facility in terms of the other.},
booktitle = {Proceedings of the 25th International Symposium on Principles and Practice of Declarative Programming},
articleno = {4},
numpages = {13},
keywords = {algebraic effect handlers, delimited control operators, effect instances, macro expressibility, prompt tags},
location = {Lisboa, Portugal},
series = {PPDP~'23}
}

@article{BrachthauserSO20Capabilities,
  author       = {Jonathan Immanuel Brachth{\"{a}}user and
                  Philipp Schuster and
                  Klaus Ostermann},
  title        = {Effects as capabilities: effect handlers and lightweight effect polymorphism},
  journal      = {Proceedings of the {ACM} on Programming Languages},
  volume       = {4},
  number       = {{OOPSLA}},
  pages        = {126:1--126:30},
  year         = {2020},
  @url          = {https://doi.org/10.1145/3428194},
  doi          = {10.1145/3428194},
}

@article{BrachthauserSO20Effekt,
  author       = {Jonathan Immanuel Brachth{\"{a}}user and
                  Philipp Schuster and
                  Klaus Ostermann},
  title        = {Effekt: Capability-passing style for type- and effect-safe, extensible
                  effect handlers in Scala},
  journal      = {Journal of Functional Programming},
  volume       = {30},
  pages        = {e8},
  year         = {2020},
  @url          = {https://doi.org/10.1017/S0956796820000027},
  doi          = {10.1017/S0956796820000027},
}

@article{XieBHSL20,
  author       = {Ningning Xie and
                  Jonathan Immanuel Brachth{\"{a}}user and
                  Daniel Hillerstr{\"{o}}m and
                  Philipp Schuster and
                  Daan Leijen},
  title        = {Effect handlers, evidently},
  journal      = {Proceedings of the {ACM} on Programming Languages},
  volume       = {4},
  number       = {{ICFP}},
  pages        = {99:1--99:29},
  year         = {2020},
  @url          = {https://doi.org/10.1145/3408981},
  doi          = {10.1145/3408981},
  timestamp    = {Sat, 08 Jan 2022 02:21:39 +0100},
  bib@url       = {https://dblp.org/rec/journals/pacmpl/XieBHSL20.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{SchusterB0O22,
  author       = {Philipp Schuster and
                  Jonathan Immanuel Brachth{\"{a}}user and
                  Marius M{\"{u}}ller and
                  Klaus Ostermann},
  @editor       = {Ranjit Jhala and
                  Isil Dillig},
  title        = {A typed continuation-passing translation for lexical effect handlers},
  booktitle    = {{PLDI}~'22: 43rd {ACM} {SIGPLAN} International Conference on Programming
                  Language Design and Implementation, San Diego, CA, USA, June 13 -
                  17, 2022},
  pages        = {566--579},
  publisher    = {{ACM}},
  year         = {2022},
  @url          = {https://doi.org/10.1145/3519939.3523710},
  doi          = {10.1145/3519939.3523710},
}

@article{MullerSSOB23,
  author       = {Marius M{\"{u}}ller and
                  Philipp Schuster and
                  Jonathan Lindegaard Starup and
                  Klaus Ostermann and
                  Jonathan Immanuel Brachth{\"{a}}user},
  title        = {From Capabilities to Regions: Enabling Efficient Compilation of Lexical
                  Effect Handlers},
  journal      = {Proceedings of the {ACM} on Programming Languages},
  volume       = {7},
  number       = {{OOPSLA2}},
  pages        = {941--970},
  year         = {2023},
  @url          = {https://doi.org/10.1145/3622831},
  doi          = {10.1145/3622831},
}

@article{10.1145/3022670.2951940,
author = {O'Connor, Liam and Chen, Zilin and Rizkallah, Christine and Amani, Sidney and Lim, Japheth and Murray, Toby and Nagashima, Yutaka and Sewell, Thomas and Klein, Gerwin},
title = {Refinement through restraint: bringing down the cost of verification},
year = {2016},
isbn = {9781450342193},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/2951913.2951940},
doi = {10.1145/2951913.2951940},
abstract = {We present a framework aimed at significantly reducing the cost of verifying certain classes of systems software, such as file systems. Our framework allows for equational reasoning about systems code written in our new language, Cogent. Cogent is a restricted, polymorphic, higher-order, and purely functional language with linear types and without the need for a trusted runtime or garbage collector. Linear types allow us to assign two semantics to the language: one imperative, suitable for efficient C code generation; and one functional, suitable for equational reasoning and verification. As Cogent is a restricted language, it is designed to easily interoperate with existing C functions and to connect to existing C verification frameworks. Our framework is based on certifying compilation: For a well-typed Cogent program, our compiler produces C code, a high-level shallow embedding of its semantics in Isabelle/HOL, and a proof that the C code correctly refines this embedding. Thus one can reason about the full semantics of real-world systems code productively and equationally, while retaining the interoperability and leanness of C. The compiler certificate is a series of language-level proofs and per-program translation validation phases, combined into one coherent top-level theorem in Isabelle/HOL.},
booktitle = {Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming},
pages = {89–102},
numpages = {14},
keywords = {verification, semantics, programming languages, linear types, file systems, Isabelle/HOL},
location = {Nara, Japan},
series = {ICFP 2016}
}


@inproceedings{Cogent,
author = {O'Connor, Liam and Chen, Zilin and Rizkallah, Christine and Amani, Sidney and Lim, Japheth and Murray, Toby and Nagashima, Yutaka and Sewell, Thomas and Klein, Gerwin},
title = {Refinement through restraint: bringing down the cost of verification},
year = {2016},
isbn = {9781450342193},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/2951913.2951940},
doi = {10.1145/2951913.2951940},
abstract = {We present a framework aimed at significantly reducing the cost of verifying certain classes of systems software, such as file systems. Our framework allows for equational reasoning about systems code written in our new language, Cogent. Cogent is a restricted, polymorphic, higher-order, and purely functional language with linear types and without the need for a trusted runtime or garbage collector. Linear types allow us to assign two semantics to the language: one imperative, suitable for efficient C code generation; and one functional, suitable for equational reasoning and verification. As Cogent is a restricted language, it is designed to easily interoperate with existing C functions and to connect to existing C verification frameworks. Our framework is based on certifying compilation: For a well-typed Cogent program, our compiler produces C code, a high-level shallow embedding of its semantics in Isabelle/HOL, and a proof that the C code correctly refines this embedding. Thus one can reason about the full semantics of real-world systems code productively and equationally, while retaining the interoperability and leanness of C. The compiler certificate is a series of language-level proofs and per-program translation validation phases, combined into one coherent top-level theorem in Isabelle/HOL.},
booktitle = {Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming},
pages = {89–102},
numpages = {14},
keywords = {Isabelle/HOL, file systems, linear types, programming languages, semantics, verification},
location = {Nara, Japan},
series = {ICFP 2016}
}

@inproceedings{Idris,
  author       = {Edwin C. Brady},
  @editor       = {Amy P. Felty and
                  Brigitte Pientka},
  title        = {Idris: Implementing a Dependently Typed Programming Language},
  booktitle    = {Proceedings of the 2014 International Workshop on Logical Frameworks
                  and Meta-languages: Theory and Practice, {LFMTP}~'14, Vienna, Austria,
                  July 17, 2014},
  pages        = {2: 1},
  publisher    = {{ACM}},
  year         = {2014},
  @url          = {https://doi.org/10.1145/2631172.2631174},
  doi          = {10.1145/2631172.2631174},
}

@inproceedings{Idris2,
  author       = {Edwin C. Brady},
  @editor       = {Anders M{\o}ller and
                  Manu Sridharan},
  title        = {Idris 2: Quantitative Type Theory in Practice},
  booktitle    = {35th European Conference on Object-Oriented Programming, {ECOOP} 2021,
                  July 11-17, 2021, Aarhus, Denmark (Virtual Conference)},
  series       = {LIPIcs},
  volume       = {194},
  pages        = {9:1--9:26},
  publisher    = {Schloss Dagstuhl - Leibniz-Zentrum f{\"{u}}r Informatik},
  year         = {2021},
  @url          = {https://doi.org/10.4230/LIPIcs.ECOOP.2021.9},
  doi          = {10.4230/LIPICS.ECOOP.2021.9},
}

@article{InductiveRecursive,
  author       = {Peter Dybjer},
  title        = {A General Formulation of Simultaneous Inductive-Recursive Definitions
                  in Type Theory},
  journal      = {Journal of Symbolic Logic},
  volume       = {65},
  number       = {2},
  pages        = {525--549},
  year         = {2000},
  @url          = {https://doi.org/10.2307/2586554},
  doi          = {10.2307/2586554},
}

@inproceedings{InductiveInductive,
  author       = {Fredrik Nordvall Forsberg and
                  Anton Setzer},
  @editor       = {Anuj Dawar and
                  Helmut Veith},
  title        = {Inductive-Inductive Definitions},
  booktitle    = {Computer Science Logic, 24th International Workshop, {CSL} 2010, 19th
                  Annual Conference of the EACSL, Brno, Czech Republic, August 23-27,
                  2010. Proceedings},
  @series       = {Lecture Notes in Computer Science},
  volume       = {6247},
  pages        = {454--468},
  publisher    = {Springer},
  year         = {2010},
  @url          = {https://doi.org/10.1007/978-3-642-15205-4\_35},
  doi          = {10.1007/978-3-642-15205-4\_35},
}

@phdthesis{ForsbergPhD,
  author       = {Fredrik Nordvall Forsberg},
  title        = {Inductive-inductive definitions},
  school       = {Swansea University, {UK}},
  year         = {2013},
  @url          = {https://ethos.bl.uk/OrderDetails.do?uin=uk.bl.ethos.752308},
}

@inproceedings{Cook2009,
  author       = {William R. Cook},
  @editor       = {Shail Arora and
                  Gary T. Leavens},
  title        = {On understanding data abstraction, revisited},
  booktitle    = {Proceedings of the 24th Annual {ACM} {SIGPLAN} Conference on Object-Oriented
                  Programming, Systems, Languages, and Applications, {OOPSLA} 2009,
                  October 25-29, 2009, Orlando, Florida, {USA}},
  pages        = {557--572},
  publisher    = {{ACM}},
  year         = {2009},
  @url          = {https://doi.org/10.1145/1640089.1640133},
  doi          = {10.1145/1640089.1640133},
}

@inbook{WhyFunc,
author = {Hughes, John},
title = {Why functional programming matters},
year = {1990},
isbn = {0201172364},
publisher = {Addison-Wesley Longman Publishing Co., Inc.},
address = {USA},
booktitle = {Research Topics in Functional Programming},
pages = {17–42},
numpages = {26}
}

@misc{UML-BPC,
  author   = {Richard A. Miner School of Computer \& Information Sciences
                  University of Massachusetts Lowell},
  title    = {Departmental {BPC} Plan},
  year     = 2024,
	@month    = may,
	@url      = {https://plans.bpcnet.org/UniversityOfMassachusettsLowell_Computer&InformationSciences_DepartmentalBPCPlan.pdf},
}


@article{ProgrammablePL,
author = {Felleisen, Matthias and Findler, Robert Bruce and Flatt, Matthew and Krishnamurthi, Shriram and Barzilay, Eli and McCarthy, Jay and Tobin-Hochstadt, Sam},
title = {A programmable programming language},
year = {2018},
issue_date = {March 2018},
publisher = {ACM},
address = {New York, NY, USA},
volume = {61},
number = {3},
issn = {0001-0782},
@url = {https://doi.org/10.1145/3127323},
doi = {10.1145/3127323},
abstract = {As the software industry enters the era of language-oriented programming, it needs programmable programming languages.},
journal = {Communications of the {ACM}},
@month = feb,
pages = {62–71},
numpages = {10}
}

@inproceedings{LanguageLibrary,
author = {Tobin-Hochstadt, Sam and St-Amour, Vincent and Culpepper, Ryan and Flatt, Matthew and Felleisen, Matthias},
title = {Languages as libraries},
year = {2011},
isbn = {9781450306638},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/1993498.1993514},
doi = {10.1145/1993498.1993514},
abstract = {Programming language design benefits from constructs for extending the syntax and semantics of a host language. While C's string-based macros empower programmers to introduce notational shorthands, the parser-level macros of Lisp encourage experimentation with domain-specific languages. The Scheme programming language improves on Lisp with macros that respect lexical scope. The design of Racket---a descendant of Scheme---goes even further with the introduction of a full-fledged interface to the static semantics of the language. A Racket extension programmer can thus add constructs that are indistinguishable from "native" notation, large and complex embedded domain-specific languages, and even optimizing transformations for the compiler backend. This power to experiment with language design has been used to create a series of sub-languages for programming with first-class classes and modules, numerous languages for implementing the Racket system, and the creation of a complete and fully integrated typed sister language to Racket's untyped base language.This paper explains Racket's language extension API via an implementation of a small typed sister language. The new language provides a rich type system that accommodates the idioms of untyped Racket. Furthermore, modules in this typed language can safely exchange values with untyped modules. Last but not least, the implementation includes a type-based optimizer that achieves promising speedups. Although these extensions are complex, their Racket implementation is just a library, like any other library, requiring no changes to the Racket implementation.},
booktitle = {Proceedings of the 32nd ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {132–141},
numpages = {10},
keywords = {extensible languages, macros, modules, typed racket},
location = {San Jose, California, USA},
series = {PLDI~'11},
}



@book{GangOfFour,
	title = {Design Patterns},
	isbn = {978-1-4496-3382-0},
	abstract = {Design Patterns demonstrates how software developers can improve the performance, maintainability, portability, and scalability of their code through the use of the Gang of Four design patterns. After a discussion of patterns methodology, reasons for using design patterns, the book delves into each of the 23 patterns.Each pattern section gives a detailed description of the pattern, refactored from either Boolean logic or simpler, less-maintainable code that you might encounter in the real world, and shows readers how to use the pattern in their code. The text walks readers through making the move from current code to the pattern, lists the benefits of using the pattern, and shows how the pattern performs after the refactoring effort, with a goal throughout of providing practical implementations.},
	pagetotal = {306},
	publisher = {Wordware Publishing, Inc.},
	author = {Lasater, Christopher G.},
	date = {2006-10-01},
	year = {2006},
	langid = {english},
	keywords = {Computers / Languages / General},
}


@article{wehr_javagi_2011,
	title = {{JavaGI}: The Interaction of Type Classes with Interfaces and Inheritance},
	volume = {33},
	issn = {0164-0925, 1558-4593},
	@url = {https://dl.acm.org/doi/10.1145/1985342.1985343},
	doi = {10.1145/1985342.1985343},
	shorttitle = {{JavaGI}},
	abstract = {The language {JavaGI} extends Java 1.5 conservatively by a generalized interface mechanism. The generalization subsumes retroactive and type-conditional interface implementations, binary methods, symmetric multiple dispatch, interfaces over families of types, and static interface methods. These features make certain coding patterns redundant, increase the expressiveness of the type system, and permit solutions to extension and integration problems with components in binary form, for which previously several unrelated extensions had been suggested.
            This article explains {JavaGI} and motivates its design. Moreover, it formalizes a core calculus for {JavaGI} and proves type soundness, decidability of typechecking, and determinacy of evaluation. The article also presents the implementation of a {JavaGI} compiler and an accompanying run-time system. The compiler, based on the Eclipse Compiler for Java, offers mostly modular static typechecking and fully modular code generation. It defers certain well-formedness checks until load time to increase flexibility and to enable full support for dynamic loading. Benchmarks show that the code generated by the compiler offers good performance. Several case studies demonstrate the practical utility of the language and its implementation.},
	pages = {1--83},
	number = {4},
	journal = {{ACM} Transactions on Programming Languages and Systems},
	shortjournal = {{ACM} Trans. Program. Lang. Syst.},
	author = {Wehr, Stefan and Thiemann, Peter},
	@urldate = {2025-02-16},
	date = {2011-07},
	year = {2011},
	langid = {english},
}

@incollection{hutchison_extensibility_2012,
	location = {Berlin, Heidelberg},
	title = {Extensibility for the Masses},
	volume = 7313,
	isbn = {978-3-642-31056-0 978-3-642-31057-7},
	@url = {http://link.springer.com/10.1007/978-3-642-31057-7_2},
	abstract = {This paper presents a new solution to the expression problem ({EP}) that works in {OO} languages with simple generics (including Java or C\#). A key novelty of this solution is that advanced typing features, including F-bounded quantiﬁcation, wildcards and variance annotations, are not needed. The solution is based on object algebras, which are an abstraction closely related to algebraic datatypes and Church encodings. Object algebras also have much in common with the traditional forms of the Visitor pattern, but without many of its drawbacks: they are extensible, remove the need for accept methods, and do not compromise encapsulation. We show applications of object algebras that go beyond toy examples usually presented in solutions for the expression problem. In the paper we develop an increasingly more complex set of features for a mini-imperative language, and we discuss a real-world application of object algebras in an implementation of remote batches. We believe that object algebras bring extensibility to the masses: object algebras work in mainstream {OO} languages, and they signiﬁcantly reduce the conceptual overhead by using only features that are used by everyday programmers.},
	pages = {2--27},
	booktitle = {{ECOOP} 2012 – Object-Oriented Programming},
	publisher = {Springer Berlin Heidelberg},
	author = {Oliveira, Bruno C. D. S. and Cook, William R.},
	@editor = {Noble, James},
	@editorb = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard},
	@editorbtype = {redactor},
	@urldate = {2025-02-16},
	year = 2012,
	langid = {english},
	doi = {10.1007/978-3-642-31057-7_2},
	@note = {Series Title: Lecture Notes in Computer Science},
}


@article{swierstra_data_2008,
	title = {Data types à la carte},
	volume = {18},
	issn = {0956-7968, 1469-7653},
	@url = {http://www.journals.cambridge.org/abstract_S0956796808006758},
	doi = {10.1017/S0956796808006758},
	abstract = {This paper describes a technique for assembling both data types and functions from isolated individual components. We also explore how the same technology can be used to combine free monads and, as a result, structure Haskell’s monolithic {IO} monad.},
	number = {4},
	journal = {Journal of Functional Programming},
	shortjournal = {J. Funct. Prog.},
	author = {Swierstra, Wouter},
	@urldate = {2025-02-16},
	@date = {2008-07},
	year = {2008},
	langid = {english},
}

@inproceedings{keep_nanopass_2013,
	location = {New York, {NY}, {USA}},
	title = {A nanopass framework for commercial compiler development},
	isbn = {978-1-4503-2326-0},
	@url = {https://doi.org/10.1145/2500365.2500618},
	doi = {10.1145/2500365.2500618},
	series = {{ICFP}~'13},
	abstract = {Contemporary compilers must typically handle sophisticated high-level source languages, generate efficient code for multiple hardware architectures and operating systems, and support source-level debugging, profiling, and other program development tools. As a result, compilers tend to be among the most complex of software systems. Nanopass frameworks are designed to help manage this complexity. A nanopass compiler is comprised of many single-task passes with formally defined intermediate languages. The perceived downside of a nanopass compiler is that the extra passes will lead to substantially longer compilation times. To determine whether this is the case, we have created a plug replacement for the commercial Chez Scheme compiler, implemented using an updated nanopass framework, and we have compared the speed of the new compiler and the code it generates against the original compiler for a large set of benchmark programs. This paper describes the updated nanopass framework, the new compiler, and the results of our experiments. The compiler produces faster code than the original, averaging 15-27\% depending on architecture and optimization level, due to a more sophisticated but slower register allocator and improvements to several optimizations. Compilation times average well within a factor of two of the original compiler, despite the slower register allocator and the replacement of five passes of the original 10 with over 50 nanopasses.},
	pages = {343--350},
	booktitle = {Proceedings of the 18th {ACM} {SIGPLAN} international conference on Functional programming},
	publisher = {ACM},
	author = {Keep, Andrew W. and Dybvig, R. Kent},
	@urldate = {2025-02-15},
	date = {2013-09-25},
	year = {2013},
}


@article{wadler_critique_1987,
	title = {A critique of {Abelson} and {Sussman} or why calculating is better than scheming},
	volume = {22},
	issn = {0362-1340},
	@url = {https://dl.acm.org/doi/10.1145/24697.24706},
	doi = {10.1145/24697.24706},
	pages = {83--94},
	number = {3},
	journal = {{SIGPLAN} Not.},
	author = {Wadler, P},
	@urldate = {2025-02-16},
	date = {1987-03-01},
	year = {1987},
}

@misc{Brown2009FunctionI,
  title={Function Inheritance : Monadic Memoization Mixins},
  author={Daniel S. Brown and William R. Cook},
  year={2009},
}

@inproceedings{ImpreciseExceptions,
author = {Peyton Jones, Simon and Reid, Alastair and Henderson, Fergus and Hoare, Tony and Marlow, Simon},
title = {A semantics for imprecise exceptions},
year = {1999},
isbn = {1581130945},
publisher = {ACM},
address = {New York, NY, USA},
@url = {https://doi.org/10.1145/301618.301637},
doi = {10.1145/301618.301637},
abstract = {Some modern superscalar microprocessors provide only imprecise exceptions. That is, they do not guarantee to report the same exception that would be encountered by a straightforward sequential execution of the program. In exchange, they offer increased performance or decreased chip area (which amount to much the same thing).This performance/precision tradeoff has not so far been much explored at the programming language level. In this paper we propose a design for imprecise exceptions in the lazy functional programming language Haskell. We discuss several designs, and conclude that imprecision is essential if the language is still to enjoy its current rich algebra of transformations. We sketch a precise semantics for the language extended with exceptions.The paper shows how to extend Haskell with exceptions without crippling the language or its compilers. We do not yet have enough experience of using the new mechanism to know whether it strikes an appropriate balance between expressiveness and performance.},
booktitle = {Proceedings of the ACM SIGPLAN 1999 Conference on Programming Language Design and Implementation},
pages = {25–36},
numpages = {12},
location = {Atlanta, Georgia, USA},
series = {PLDI~'99}
}


@article{jeannin_cocaml_2017,
	title = {{CoCaml}: Functional Programming with Regular Coinductive Types},
	volume = {150},
	issn = {01692968, 18758681},
	url = {https://journals.sagepub.com/doi/full/10.3233/FI-2017-1473},
	doi = {10.3233/FI-2017-1473},
	shorttitle = {{CoCaml}},
	abstract = {Functional languages offer a high level of abstraction, which results in programs that are elegant and easy to understand. Central to the development of functional programming are inductive and coinductive types and associated programming constructs, such as pattern-matching. Whereas inductive types have a long tradition and are well supported in most languages, coinductive types are subject of more recent research and are less mainstream.},
	pages = {347--377},
	number = {3},
	journal = {Fundamenta Informaticae},
	shortjournal = {{FI}},
	author = {Jeannin, Jean-Baptiste and Kozen, Dexter and Silva, Alexandra},
	@editor = {Baelde, David and Carayol, Arnaud and Matthes, Ralph and Walukiewicz, Igor},
	date = {2017-03-03},
	langid = {english},
  year = {2017}
}

@inproceedings{FunctionalCorrespondence,
author = {Ager, Mads Sig and Biernacki, Dariusz and Danvy, Olivier and Midtgaard, Jan},
title = {A functional correspondence between evaluators and abstract machines},
year = {2003},
isbn = {1581137052},
publisher = {ACM},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/888251.888254},
doi = {10.1145/888251.888254},
abstract = {We bridge the gap between functional evaluators and abstract machines for the λ-calculus, using closure conversion, transformation into continuation-passing style, and defunctionalization.We illustrate this approach by deriving Krivine's abstract machine from an ordinary call-by-name evaluator and by deriving an ordinary call-by-value evaluator from Felleisen et al.'s CEK machine. The first derivation is strikingly simpler than what can be found in the literature. The second one is new. Together, they show that Krivine's abstract machine and the CEK machine correspond to the call-by-name and call-by-value facets of an ordinary evaluator for the λ-calculus.We then reveal the denotational content of Hannan and Miller's CLS machine and of Landin's SECD machine. We formally compare the corresponding evaluators and we illustrate some degrees of freedom in the design spaces of evaluators and of abstract machines for the λ-calculus with computational effects.Finally, we consider the Categorical Abstract Machine and the extent to which it is more of a virtual machine than an abstract machine.},
booktitle = {Proceedings of the 5th ACM SIGPLAN International Conference on Principles and Practice of Declaritive Programming},
pages = {8–19},
numpages = {12},
keywords = {transformation into continuation-passing style (CPS), interpreters, defunctionalization, closure conversion, abstract machines},
location = {Uppsala, Sweden},
series = {PPDP '03}
}

@article{SyntacticCorrespondence,
author = {Biernacka, Magorzata and Danvy, Olivier},
title = {A syntactic correspondence between context-sensitive calculi and abstract machines},
year = {2007},
issue_date = {April, 2007},
publisher = {Elsevier Science Publishers Ltd.},
address = {GBR},
volume = {375},
number = {1–3},
issn = {0304-3975},
url = {https://doi.org/10.1016/j.tcs.2006.12.028},
doi = {10.1016/j.tcs.2006.12.028},
abstract = {We present a systematic construction of environment-based abstract machines from context-sensitive calculi of explicit substitutions, and we illustrate it with ten calculi and machines for applicative order with an abort operation, normal order with generalized reduction and call/cc, the lambda-mu-calculus, delimited continuations, stack inspection, proper tail-recursion, and lazy evaluation. Most of the machines already exist but they have been obtained independently and are only indirectly related to the corresponding calculi. All of the calculi are new and they make it possible directly to reason about the execution of the corresponding machines.},
journal = {Theoretical Computer Science},
month = apr,
pages = {76–108},
numpages = {33},
keywords = {Contexts, Continuations, Defunctionalization, Delimited continuations, Environment-based machines, Explicit substitutions, Proper tail recursion, Reduction semantics, Refocusing, Stack inspection}
}

@inproceedings{DefinitionalInterpreters,
author = {Reynolds, John C.},
title = {Definitional interpreters for higher-order programming languages},
year = {1972},
isbn = {9781450374927},
publisher = {ACM},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/800194.805852},
doi = {10.1145/800194.805852},
abstract = {Higher-order programming languages (i.e., languages in which procedures or labels can occur as values) are usually defined by interpreters which are themselves written in a programming language based on the lambda calculus (i.e., an applicative language such as pure LISP). Examples include McCarthy's definition of LISP, Landin's SECD machine, the Vienna definition of PL/I, Reynolds' definitions of GEDANKEN, and recent unpublished work by L. Morris and C. Wadsworth. Such definitions can be classified according to whether the interpreter contains higher-order functions, and whether the order of application (i.e., call-by-value versus call-by-name) in the defined language depends upon the order of application in the defining language. As an example, we consider the definition of a simple applicative programming language by means of an interpreter written in a similar language. Definitions in each of the above classifications are derived from one another by informal but constructive methods. The treatment of imperative features such as jumps and assignment is also discussed.},
booktitle = {Proceedings of the ACM Annual Conference - Volume 2},
pages = {717–740},
numpages = {24},
keywords = {Applicative language, Closure, Continuation, GEDANKEN, Higher-order function, Interpreter, J-operator, LISP, Lambda calculus, Language definition, Order of application, PAL, Programming language, Reference, SECD machine},
location = {Boston, Massachusetts, USA},
series = {ACM '72}
}

@inproceedings{RefunctionalizationCopatterns,
author = {Rendel, Tillmann and Trieflinger, Julia and Ostermann, Klaus},
title = {Automatic refunctionalization to a language with copattern matching: with applications to the expression problem},
year = {2015},
isbn = {9781450336697},
publisher = {ACM},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2784731.2784763},
doi = {10.1145/2784731.2784763},
abstract = {Defunctionalization and refunctionalization establish a correspondence between first-class functions and pattern matching, but the correspondence is not symmetric: Not all uses of pattern matching can be automatically refunctionalized to uses of higher-order functions. To remedy this asymmetry, we generalize from first-class functions to arbitrary codata. This leads us to full defunctionalization and refunctionalization between a codata language based on copattern matching and a data language based on pattern matching. We observe how programs can be written as matrices so that they are modularly extensible in one dimension but not the other. In this representation, defunctionalization and refunctionalization correspond to matrix transposition which effectively changes the dimension of extensibility a program supports. This suggests applications to the expression problem.},
booktitle = {Proceedings of the 20th ACM SIGPLAN International Conference on Functional Programming},
pages = {269–279},
numpages = {11},
keywords = {Uroboro, Refunctionalization, Expression Problem, Defunctionalization, Copattern Matching, Codata},
location = {Vancouver, BC, Canada},
series = {ICFP 2015}
}

@article{SmallStepBigStepMachines,
author = {Danvy, Olivier and Millikin, Kevin},
title = {On the equivalence between small-step and big-step abstract machines: a simple application of lightweight fusion},
year = {2008},
issue_date = {April, 2008},
publisher = {Elsevier North-Holland, Inc.},
address = {USA},
volume = {106},
number = {3},
issn = {0020-0190},
url = {https://doi.org/10.1016/j.ipl.2007.10.010},
doi = {10.1016/j.ipl.2007.10.010},
abstract = {We show how Ohori and Sasano's recent lightweight fusion by fixed-point promotion provides a simple way to prove the equivalence of the two standard styles of specification of abstract machines: (1) in small-step form, as a state-transition function together with a 'driver loop', i.e., a function implementing the iteration of this transition function; and (2) in big-step form, as a tail-recursive function that directly maps a given configuration to a final state, if any. The equivalence hinges on our observation that for abstract machines, fusing a small-step specification yields a big-step specification. We illustrate this observation here with a recognizer for Dyck words, the CEK machine, and Krivine's machine with call/cc. The need for such a simple proof is motivated by our current work on small-step abstract machines as obtained by refocusing a function implementing a reduction semantics (a syntactic correspondence), and big-step abstract machines as obtained by CPS-transforming and then defunctionalizing a function implementing a big-step semantics (a functional correspondence).},
journal = {Information Processing Letters},
month = apr,
pages = {100–109},
numpages = {10},
keywords = {Abstract machines, Program derivation, Programming calculi, Programming languages, Refocusing, Warm fusion}
}

@inproceedings{DefunctionalizedInterpreters,
author = {Danvy, Olivier},
title = {Defunctionalized interpreters for programming languages},
year = {2008},
isbn = {9781595939197},
publisher = {ACM},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1411204.1411206},
doi = {10.1145/1411204.1411206},
abstract = {This document illustrates how functional implementations of formal semantics (structural operational semantics, reduction semantics, small-step and big-step abstract machines, natural semantics, and denotational semantics) can be transformed into each other. These transformations were foreshadowed by Reynolds in "Definitional Interpreters for Higher-Order Programming Languages" for functional implementations of denotational semantics, natural semantics, and big-step abstract machines using closure conversion, CPS transformation, and defunctionalization. Over the last few years, the author and his students have further observed that functional implementations of small-step and of big-step abstract machines are related using fusion by fixed-point promotion and that functional implementations of reduction semantics and of small-step abstract machines are related using refocusing and transition compression. It furthermore appears that functional implementations of structural operational semantics and of reduction semantics are related as well, also using CPS transformation and defunctionalization. This further relation provides an element of answer to Felleisen's conjecture that any structural operational semantics can be expressed as a reduction semantics: for deterministic languages, a reduction semantics is a structural operational semantics in continuation style, where the reduction context is a defunctionalized continuation. As the defunctionalized counterpart of the continuation of a one-step reduction function, a reduction context represents the rest of the reduction, just as an evaluation context represents the rest of the evaluation since it is the defunctionalized counterpart of the continuation of an evaluation function.},
booktitle = {Proceedings of the 13th ACM SIGPLAN International Conference on Functional Programming},
pages = {131–142},
numpages = {12},
keywords = {structural operational semantics, small-step abstract machines, refocusing, reduction semantics, natural semantics, interruptions, defunctionalization, cps transformation, continuations, context-sensitive reduction semantics, big-step abstract machines},
location = {Victoria, BC, Canada},
series = {ICFP '08}
}

@inproceedings{WalkInTheSemanticPark,
author = {Danvy, Olivier and Johannsen, Jacob and Zerny, Ian},
title = {A walk in the semantic park},
year = {2011},
isbn = {9781450304856},
publisher = {ACM},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1929501.1929503},
doi = {10.1145/1929501.1929503},
abstract = {To celebrate the 20th anniversary of PEPM, we are inviting you to a walk in the semantic park and to inter-derive reduction-based and reduction-free negational normalization functions.},
booktitle = {Proceedings of the 20th ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation},
pages = {1–12},
numpages = {12},
keywords = {abstract machines, continuation-passing style (cps), continuations, cps transformation, de morgan laws, defunctionalization, evaluation contexts, negational normal forms, reduction contexts, reduction semantics, reduction-based normalization, reduction-free normalization, refocusing, refunctionalization},
@location = {Austin, Texas, USA},
series = {PEPM '11}
}

@article{InterDerivingSemanticArtifactsOOP,
author = {Danvy, Olivier and Johannsen, Jacob},
title = {Inter-deriving semantic artifacts for object-oriented programming},
year = {2010},
issue_date = {August, 2010},
publisher = {Academic Press, Inc.},
address = {USA},
volume = {76},
number = {5},
issn = {0022-0000},
url = {https://doi.org/10.1016/j.jcss.2009.10.004},
doi = {10.1016/j.jcss.2009.10.004},
abstract = {We present a new abstract machine for Abadi and Cardelli's untyped non-imperative calculus of objects. This abstract machine mechanically corresponds to both the reduction semantics (i.e., small-step operational semantics) and the natural semantics (i.e., big-step operational semantics) specified in Abadi and Cardelli's monograph. To move closer to actual implementations, which use environments rather than actual substitutions, we then represent methods as closures and we present three new semantic artifacts for a version of Abadi and Cardelli's calculus with explicit substitutions: a reduction semantics, an environment-based abstract machine, and a natural semantics (i.e., an interpreter) with environments. These three new semantic artifacts mechanically correspond to each other, and the two abstract machines are bisimilar. Their significance lies in the fact that they have not been designed from scratch and then proved correct; instead, they have been inter-derived. To illustrate the inter-derivation and to make this article stand-alone, we also comprehensively treat the example of negational normalization over Boolean formulas, in appendix.},
journal = {Journal of Computer and System Sciences},
month = aug,
pages = {302–323},
numpages = {22},
keywords = {Syntactic correspondence, Reduction semantics, Natural semantics, Functional correspondence, Functional calculus of objects, Abstract machine}
}

@article{RefunctionalizationAtWork,
author = {Danvy, Olivier and Millikin, Kevin},
title = {Refunctionalization at work},
year = {2009},
issue_date = {June, 2009},
publisher = {Elsevier North-Holland, Inc.},
address = {USA},
volume = {74},
number = {8},
issn = {0167-6423},
url = {https://doi.org/10.1016/j.scico.2007.10.007},
doi = {10.1016/j.scico.2007.10.007},
abstract = {We present the left inverse of Reynolds' defunctionalization and we show its relevance to programming and to programming languages. We propose two methods to transform a program that is almost in defunctionalized form into one that is actually in defunctionalized form, and we illustrate them with a recognizer for Dyck words and with Dijkstra's shunting-yard algorithm.},
journal = {Sci. Comput. Program.},
month = jun,
pages = {534–549},
numpages = {16},
keywords = {Abstract machines, Continuation-passing style (CPS), Continuations, Defunctionalization, Refunctionalization, Shunting-yard algorithm}
}

@article{InterDerivingSmallStepBigStepCBNeed,
author = {Danvy, Olivier and Millikin, Kevin and Munk, Johan and Zerny, Ian},
title = {On inter-deriving small-step and big-step semantics: A case study for storeless call-by-need evaluation},
year = {2012},
issue_date = {June, 2012},
publisher = {Elsevier Science Publishers Ltd.},
address = {GBR},
volume = {435},
issn = {0304-3975},
url = {https://doi.org/10.1016/j.tcs.2012.02.023},
doi = {10.1016/j.tcs.2012.02.023},
abstract = {Starting from the standard call-by-need reduction for the @l-calculus that is common to Ariola, Felleisen, Maraist, Odersky, and Wadler, we inter-derive a series of hygienic semantic artifacts: a reduction-free storeless abstract machine, a continuation-passing evaluation function, and what appears to be the first heapless natural semantics for call-by-need evaluation. Furthermore we observe that the evaluation function implementing this natural semantics is in defunctionalized form. The refunctionalized counterpart of this evaluation function implements an extended direct semantics in the sense of Cartwright and Felleisen. Overall, the semantic artifacts presented here are simpler than many other such artifacts that have been independently worked out, and which require ingenuity, skill, and independent soundness proofs on a case-by-case basis. They are also simpler to inter-derive because the inter-derivational tools (e.g., refocusing and defunctionalization) already exist.},
journal = {Theoretical Computer Science},
month = jun,
pages = {21–42},
numpages = {22}
}

@inproceedings{DefunctionalizedInterpretersCBNeed,
author = {Danvy, Olivier and Millikin, Kevin and Munk, Johan and Zerny, Ian},
title = {Defunctionalized interpreters for call-by-need evaluation},
year = {2010},
isbn = {3642122507},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/978-3-642-12251-4_18},
doi = {10.1007/978-3-642-12251-4_18},
abstract = {Starting from the standard call-by-need reduction for the λ-calculus that is common to Ariola, Felleisen, Maraist, Odersky, and Wadler, we inter-derive a series of hygienic semantic artifacts: a reduction-free stateless abstract machine, a continuation-passing evaluation function, and what appears to be the first heapless natural semantics for call-by-need evaluation. Furthermore we observe that a data structure and a judgment in this natural semantics are in defunctionalized form. The refunctionalized counterpart of this evaluation function is an extended direct semantics in the sense of Cartwright and Felleisen.Overall, the semantic artifacts presented here are simpler than many other such artifacts that have been independently worked out, and which require ingenuity, skill, and independent soundness proofs on a case-by-case basis. They are also simpler to inter-derive because the inter-derivational tools (e.g., refocusing and defunctionalization) already exist.},
booktitle = {Proceedings of the 10th International Conference on Functional and Logic Programming},
pages = {240–256},
numpages = {17},
location = {Sendai, Japan},
series = {FLOPS'10}
}

@inproceedings{SyntheicOperationalCBNeed,
author = {Danvy, Olivier and Zerny, Ian},
title = {A synthetic operational account of call-by-need evaluation},
year = {2013},
isbn = {9781450321549},
publisher = {ACM},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2505879.2505898},
doi = {10.1145/2505879.2505898},
abstract = {We present the first operational account of call by need that connects syntactic theory and implementation practice. Syntactic theory: the storeless operational semantics using syntax rewriting to account for demand-driven computation and for caching intermediate results. Implementational practice: the store-based operational technique using memo-thunks to implement demand-driven computation and to cache intermediate results for subsequent sharing. The implementational practice was initiated by Landin and Wadsworth and is prevalent today to implement lazy programming languages such as Haskell. The syntactic theory was initiated by Ariola, Felleisen, Maraist, Odersky and Wadler and is prevalent today to reason equationally about lazy programs, on par with Barendregt et al.'s term graphs. Nobody knows, however, how the theory of call by need compares to the practice of call by need: all that is known is that the theory of call by need agrees with the theory of call by name, and that the practice of call by need optimizes the practice of call by name.Our operational account takes the form of three new calculi for lazy evaluation of lambda-terms and our synthesis takes the form of three lock-step equivalences. The first calculus is a hereditarily compressed variant of Ariola et al.'s call-by-need lambda-calculus and makes "neededness" syntactically explicit. The second calculus distinguishes between strict bindings (which are induced by demand-driven computation) and non-strict bindings (which are used for caching intermediate results). The third calculus uses memo-thunks and an algebraic store. The first calculus syntactically corresponds to a storeless abstract machine, the second to an abstract machine with local stores, and the third to a lazy Krivine machine, i.e., a traditional store-based abstract machine implementing lazy evaluation. The machines are intensionally compatible with extensional reasoning about lazy programs and they are lock-step equivalent. Each machine functionally corresponds to a natural semantics for call by need in the style of Launchbury, though for non-preprocessed λ-terms.Our results reveal a genuine and principled unity of computational theory and computational practice, one that readily applies to variations on the general theme of call by need.},
booktitle = {Proceedings of the 15th Symposium on Principles and Practice of Declarative Programming},
pages = {97–108},
numpages = {12},
keywords = {abstract machines, call by need, functional correspondence, lazy evaluation, natural semantics, reduction semantics, syntactic correspondence, syntactic theories},
location = {Madrid, Spain},
series = {PPDP '13}
}
